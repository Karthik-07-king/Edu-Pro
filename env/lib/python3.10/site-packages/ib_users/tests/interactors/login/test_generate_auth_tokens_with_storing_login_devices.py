import datetime

import pytest
import mock
from django.test import override_settings


class TestGenerateTokensWithStoringLoginDevicesInteractor:
    @pytest.fixture()
    def user_account_storage(self):
        from ib_users.interactors.storages.user_accounts_storage import \
            UserAccountsStorage
        return mock.create_autospec(UserAccountsStorage)

    @pytest.fixture()
    def user_login_device_details_storage_mock(self):
        from ib_users.interactors.storages.user_login_device_details_storage import \
            UserLoginDeviceDetailsStorage
        return mock.create_autospec(UserLoginDeviceDetailsStorage)

    @pytest.fixture()
    def user_auth_token_generator_mock(self):
        from ib_users.interactors.third_party.user_tokens_generator import \
            UserAuthTokensGenerator
        return mock.create_autospec(UserAuthTokensGenerator)

    @pytest.fixture()
    def generate_auth_tokens_mock(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            generate_user_auth_tokens_mock
        return generate_user_auth_tokens_mock(mocker=mocker)

    @pytest.fixture()
    def create_user_login_device_details_mock(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            create_user_login_device_details_mock
        return create_user_login_device_details_mock(mocker=mocker)

    @pytest.fixture()
    def interactor(self, user_account_storage, user_login_device_details_storage_mock,
                   user_auth_token_generator_mock):
        from ib_users.interactors.login. \
            generate_auth_tokens_interactor import \
            GenerateAuthTokensInteractor
        interactor = GenerateAuthTokensInteractor(
            user_account_storage=user_account_storage,
            user_login_device_details_storage=user_login_device_details_storage_mock,
            user_auth_tokens_generator=user_auth_token_generator_mock)
        return interactor

    @pytest.fixture()
    def presenter_mock(self):
        from ib_users.interactors.presenters.user_login_presenter import \
            UserLoginPresenter
        return mock.create_autospec(UserLoginPresenter)

    @pytest.fixture()
    def logout_in_devices_except_of_given_access_tokens_mocker(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            logout_in_devices_except_of_given_access_tokens_mock
        return logout_in_devices_except_of_given_access_tokens_mock(mocker=mocker)

    def test_with_valid_details_should_create_auth_tokens_and_login_device_details(
            self, interactor, create_user_login_device_details_mock,
            generate_auth_tokens_mock, presenter_mock):
        # arrange
        from ib_users.interactors.third_party.user_tokens_generator import \
            UserAuthTokensDTO
        from ib_users.interactors.storages.user_login_device_details_storage import \
            UserDeviceIdAndAccessTokenDTO

        user_id = "12345678-1234-1234-1234-123456789011"
        device_id_with_access_token = UserDeviceIdAndAccessTokenDTO(
            device_id="Device1",
            access_token="AccessToken")
        expected_response = mock.Mock()
        user_auth_tokens = UserAuthTokensDTO(
            user_id=user_id,
            access_token="AccessToken",
            refresh_token="RefreshToken",
            expires_in=datetime.datetime(2021, 12, 12, 12, 12, 12))

        generate_auth_tokens_mock.return_value = user_auth_tokens
        create_user_login_device_details_mock.return_value = None
        presenter_mock.get_user_login_response.return_value = expected_response

        # act
        actual_response = interactor.generate_auth_tokens_wrapper(
            user_id=user_id, device_id=device_id_with_access_token.device_id,
            presenter=presenter_mock)

        # assert
        generate_auth_tokens_mock.assert_called_once_with(
            user_id=user_id, expiry_in_seconds=None, application_id=None)
        create_user_login_device_details_mock.assert_called_once_with(
            user_id=user_id, device_access_token_dto=device_id_with_access_token)
        presenter_mock.get_user_login_response.assert_called_once_with(
            user_tokens=user_auth_tokens)
        assert actual_response == expected_response

    @override_settings(RESTRICT_USER_TO_SINGLE_LOGIN_SESSION='TRUE')
    def test_with_valid_details_should_create_auth_tokens_logout_from_devices(
            self, interactor, create_user_login_device_details_mock,
            generate_auth_tokens_mock, presenter_mock,
            logout_in_devices_except_of_given_access_tokens_mocker):
        # arrange
        from ib_users.interactors.third_party.user_tokens_generator import \
            UserAuthTokensDTO
        from ib_users.interactors.storages.user_login_device_details_storage import \
            UserDeviceIdAndAccessTokenDTO

        user_id = "12345678-1234-1234-1234-123456789011"
        device_id_with_access_token = UserDeviceIdAndAccessTokenDTO(
            device_id="Device1",
            access_token="AccessToken")
        expected_response = mock.Mock()
        user_auth_tokens = UserAuthTokensDTO(
            user_id=user_id,
            access_token="AccessToken",
            refresh_token="RefreshToken",
            expires_in=datetime.datetime(2021, 12, 12, 12, 12, 12))

        generate_auth_tokens_mock.return_value = user_auth_tokens
        create_user_login_device_details_mock.return_value = None
        presenter_mock.get_user_login_response.return_value = expected_response

        # act
        actual_response = interactor.generate_auth_tokens_wrapper(
            user_id=user_id,  device_id=device_id_with_access_token.device_id,
            presenter=presenter_mock)

        # assert
        generate_auth_tokens_mock.assert_called_once_with(
            user_id=user_id, expiry_in_seconds=None, application_id=None)
        create_user_login_device_details_mock.assert_called_once_with(
            user_id=user_id, device_access_token_dto=device_id_with_access_token)
        presenter_mock.get_user_login_response.assert_called_once_with(
            user_tokens=user_auth_tokens)
        logout_in_devices_except_of_given_access_tokens_mocker.assert_called_once_with(
            user_id=user_id, access_tokens=[user_auth_tokens.access_token])
        assert actual_response == expected_response
