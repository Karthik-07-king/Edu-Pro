import datetime
from unittest.mock import create_autospec, patch

import pytest
from ib_users.storages.oauth2_sql_storage import OAuth2SQLStorage

from ib_users.interactors import LoginWithEmail
from ib_users.validators.base_validator import CustomException

from ib_users.utils.tests_utils import TestsUtils
from ib_users.interactors.storages.user_accounts_storage import \
    EmailAndPasswordDTO, UserAccountsStorage
from ib_users.interactors.storages.user_login_device_details_storage import \
    UserLoginDeviceDetailsStorage

from ib_users.exceptions.custom_exception_constants import INVALID_EMAIL, \
    PASSWORD_MIN_LENGTH_IS, PASSWORD_AT_LEAST_1_SPECIAL_CHARACTER, \
    NOT_REGISTERED_USER, INCORRECT_PASSWORD, USER_ACCOUNT_IS_DEACTIVATED


class TestGetTokenForLoginWithEmail:
    # TODO update the pytest patch with mocker(Refactor patch statements with mocker)

    @pytest.fixture()
    def validate_user_login_devices_details_mock(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            validate_user_login_devices_details_mock
        return validate_user_login_devices_details_mock(mocker=mocker)

    @pytest.mark.parametrize("email",
                             ["", "a@bc",
                              "hello.boy#gmail.com",
                              "3010@gmail.l"])
    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_invalid_email_then_raise_exception(
            self, get_user_id_for_given_login_data, email):
        password = "password@#"
        device_id = "Device1"
        get_user_id_for_given_login_data.side_effect = CustomException.from_exception_message_DTO(
            exception_message_DTO=INVALID_EMAIL)
        oauth2_sql_storage = OAuth2SQLStorage()

        self._init_interactor(email=email, password=password)

        with pytest.raises(CustomException) as invalid_email:
            self.login_interactor.get_auth_tokens_given_login_data(
                email_login_dto=self.email_login_dto,
                oauth2_sql_storage=oauth2_sql_storage,
                device_id=device_id)

        TestsUtils.assert_custom_exception(INVALID_EMAIL, invalid_email)

    @pytest.mark.parametrize("password,exception_message", [
        ("", PASSWORD_MIN_LENGTH_IS),
        ("a" * 7, PASSWORD_MIN_LENGTH_IS),
        ("abU" * 15, PASSWORD_AT_LEAST_1_SPECIAL_CHARACTER)])
    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_valid_email_and_invalid_password_then_raise_exception(
            self, get_user_id_for_given_login_data, password,
            exception_message):
        email = "jim@gog.com"
        device_id = "Device1"
        get_user_id_for_given_login_data.side_effect = CustomException.from_exception_message_DTO(
            exception_message_DTO=exception_message)
        oauth2_sql_storage = OAuth2SQLStorage()
        self._init_interactor(email=email, password=password)

        with pytest.raises(CustomException) as invalid_password:
            self.login_interactor.get_auth_tokens_given_login_data(
                email_login_dto=self.email_login_dto,
                oauth2_sql_storage=oauth2_sql_storage,
                device_id=device_id)
        TestsUtils.assert_custom_exception(exception_message, invalid_password)

    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_not_registered_email_then_raise_exception(
            self, get_user_id_for_given_login_data):
        email = "jim@gog.com"
        password = "password@#"
        device_id = "Device1"
        get_user_id_for_given_login_data.side_effect = CustomException.from_exception_message_DTO(
            exception_message_DTO=NOT_REGISTERED_USER)
        oauth2_sql_storage = OAuth2SQLStorage()
        self._init_interactor(email=email, password=password)

        with pytest.raises(CustomException) as not_registered_user:
            self.login_interactor.get_auth_tokens_given_login_data(
                email_login_dto=self.email_login_dto,
                oauth2_sql_storage=oauth2_sql_storage,
                device_id=device_id)

        TestsUtils.assert_custom_exception(NOT_REGISTERED_USER,
                                           not_registered_user)

    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_incorrect_password_then_raise_exception(
            self, get_user_id_for_given_login_data):
        email = "jim@gog.com"
        password = "password@#"
        device_id = "Device1"
        get_user_id_for_given_login_data.side_effect = CustomException.from_exception_message_DTO(
            exception_message_DTO=INCORRECT_PASSWORD)
        oauth2_sql_storage = OAuth2SQLStorage()
        self._init_interactor(email=email, password=password)

        with pytest.raises(CustomException) as incorrect_password_exception:
            self.login_interactor.get_auth_tokens_given_login_data(
                email_login_dto=self.email_login_dto,
                oauth2_sql_storage=oauth2_sql_storage,
                device_id=device_id)

        TestsUtils.assert_custom_exception(INCORRECT_PASSWORD,
                                           incorrect_password_exception)

    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_deactivated_user_then_raise_exception(
            self, get_user_id_for_given_login_data,
            validate_user_login_devices_details_mock):
        email = "jim@gog.com"
        password = "password@#"
        device_id = "Device1"
        get_user_id_for_given_login_data.side_effect = CustomException.from_exception_message_DTO(
            exception_message_DTO=USER_ACCOUNT_IS_DEACTIVATED)
        oauth2_sql_storage = OAuth2SQLStorage()
        self._init_interactor(email=email, password=password)

        with pytest.raises(CustomException) as inactive_user_exception:
            self.login_interactor.get_auth_tokens_given_login_data(
                email_login_dto=self.email_login_dto,
                oauth2_sql_storage=oauth2_sql_storage,
                device_id=device_id)

        TestsUtils.assert_custom_exception(USER_ACCOUNT_IS_DEACTIVATED,
                                           inactive_user_exception)

    @pytest.fixture()
    def create_user_auth_token_and_login_devices_details_mock(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            create_user_auth_token_and_login_devices_details_mock
        return create_user_auth_token_and_login_devices_details_mock(
            mocker=mocker)

    @patch(
        "ib_users.interactors.login.login_with_email.LoginWithEmail.get_user_id_for_given_login_data")
    def test_login_with_valid_email_and_valid_password(
            self, get_user_id_for_given_login_data,
            create_user_auth_token_and_login_devices_details_mock,
            validate_user_login_devices_details_mock):
        email = "sample@google.co"
        password = "password@#"
        user_id = "1"
        device_id = "Device1"
        from ib_users.interactors.third_party.user_tokens_generator import \
            UserAuthTokensDTO
        new_auth_tokens_dto = UserAuthTokensDTO(
            "user_id", "new_access_token", "new_refresh_token",
            datetime.datetime.now())
        get_user_id_for_given_login_data.return_value = user_id
        create_user_auth_token_and_login_devices_details_mock.return_value = new_auth_tokens_dto
        oauth2_sql_storage = OAuth2SQLStorage()
        self._init_interactor(email=email, password=password)

        self.login_interactor.get_auth_tokens_given_login_data(
            email_login_dto=self.email_login_dto,
            oauth2_sql_storage=oauth2_sql_storage,
            device_id=device_id)

        get_user_id_for_given_login_data.assert_called_once_with(
            email_login_dto=self.email_login_dto, device_id=device_id)
        create_user_auth_token_and_login_devices_details_mock.assert_called_once_with(
            user_id=user_id, device_id=device_id)

    def _init_interactor(self, email, password):
        storage_mock = create_autospec(UserAccountsStorage)
        user_login_device_storage_mock = create_autospec(UserLoginDeviceDetailsStorage)
        self.login_interactor = LoginWithEmail(
            storage=storage_mock,
            user_login_device_details_storage=user_login_device_storage_mock)
        self.email_login_dto = EmailAndPasswordDTO(email, password)
