import datetime
import uuid
from unittest import mock

import freezegun
import pytest
from django.conf import settings
from django.test import override_settings

from ib_users.constants import otp_verification_constants
from ib_users.constants.otp_constants import OTPMessageFormatConstants
from ib_users.exceptions.phone_number_validation_exception_messges import \
    INVALID_PHONE_NUMBER
from ib_users.exceptions import invalid_phone_number_exception, \
    user_account_exceptions
from ib_users.exceptions import registration_exceptions
from ib_users.tests.common_fixtures.interactors import \
    get_validate_phone_number_mock, get_send_otp_to_user_phone_number_mock
from ib_users.tests.factories.interactor_dtos import UserIdWiseCanUpdatePhoneNumberDetailsDTOFactory
from ib_users.tests.factories.interface_dtos import \
    UpdateUserAccountPhoneNumberDTOFactory
from ib_users.interactors.DTOs import common_dtos as interactor_common_dtos
from ib_users.validators import base_validator
from ib_users.tests.factories import storage_dtos as storage_dtos_factories


class TestUpdateUserAccountPhoneNumberInteractor:

    @pytest.fixture
    def storage_mock(self):
        from ib_users.interactors.storages.user_accounts_storage import\
            UserAccountsStorage
        return mock.create_autospec(UserAccountsStorage)

    @pytest.fixture
    def interactor(self, storage_mock):
        from ib_users.interactors\
            .update_user_account_phone_number_interactor \
            import UpdateUserAccountPhoneNumberInteractor
        return UpdateUserAccountPhoneNumberInteractor(storage_mock)

    @pytest.fixture
    def verify_through_otp_interactor_mock(self):
        from ib_users.interactors.verify_otp_through import \
            VerifyThroughOTPInteractor
        return mock.create_autospec(VerifyThroughOTPInteractor)

    @pytest.fixture
    def setup_data(self):
        user_id = str(uuid.uuid4())
        phone_number = '998877665544'
        country_code = '+91'
        update_user_account_phone_number_dto = \
            UpdateUserAccountPhoneNumberDTOFactory(
                user_id=user_id,
                phone_number=phone_number
            )
        phone_number_dto = interactor_common_dtos.PhoneNumberDTO(
            phone_number=phone_number,
            country_code=country_code
        )

        user_account_dto = storage_dtos_factories.UserAccountDTOFactory(
            user_id=user_id)

        return user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto

    def test_when_new_phone_number_is_invalid(
            self, interactor, storage_mock, setup_data, mocker):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        validate_phone_number_mock = get_validate_phone_number_mock(mocker)
        validate_phone_number_mock.side_effect = \
            invalid_phone_number_exception.InvalidPhoneNumberException(
                message=INVALID_PHONE_NUMBER.message,
                exception_type=INVALID_PHONE_NUMBER.code)

        with pytest.raises(
                invalid_phone_number_exception.InvalidPhoneNumberException) \
                as exception:
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        validate_phone_number_mock.assert_called_once_with(phone_number_dto)

        storage_mock.is_user_id_exists.assert_not_called()

    def test_when_user_account_does_not_exist(
            self, interactor, storage_mock, setup_data, mocker):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = False

        with pytest.raises(
                user_account_exceptions.InvalidUserIdException):
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        storage_mock.is_user_id_exists.assert_called_once_with(user_id)
        storage_mock.is_user_account_active.assert_not_called()

    def test_when_user_account_is_not_active(
            self, interactor, storage_mock, setup_data, mocker):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = False

        with pytest.raises(base_validator.CustomException):
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        storage_mock.is_user_account_active.assert_called_once_with(user_id)
        storage_mock.get_user_account_details.assert_not_called()

    def test_when_new_phone_details_is_same_as_existing_ones(
            self, interactor, storage_mock, setup_data, mocker):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        user_account_dto.phone_number = phone_number_dto.phone_number

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = True
        storage_mock.get_user_account_details.return_value = user_account_dto

        with pytest.raises(base_validator.CustomException):
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        storage_mock.get_user_account_details.assert_called_once_with(user_id)
        storage_mock.check_user_exists_with_phone_number.assert_not_called()

    def test_when_new_phone_number_details_already_linked(
            self, interactor, storage_mock, setup_data, mocker):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = True
        storage_mock.get_user_account_details.return_value = user_account_dto
        storage_mock.check_user_exists_with_phone_number.side_effect = \
            registration_exceptions.\
            AccountWithThisPhoneNumberAlreadyExistsException

        with pytest.raises(
                registration_exceptions.
                AccountWithThisPhoneNumberAlreadyExistsException):
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        storage_mock.check_user_exists_with_phone_number.\
            assert_called_once_with(phone_number_dto)
        storage_mock.get_user_latest_update_phone_number_log_details.\
            assert_not_called()

    @pytest.fixture
    def get_is_users_can_update_phone_number_details_mock(self, mocker):
        from ib_users.tests.common_fixtures.interactors import \
            get_is_users_can_update_phone_number_details_mock
        return get_is_users_can_update_phone_number_details_mock(mocker)

    @override_settings(SWAP_PHONE_NUMBERS_WHILE_UPDATING=False)
    @freezegun.freeze_time('2022-03-02')
    def test_when_user_already_has_verified_update_log_without_interval_completion(
            self, interactor, storage_mock, setup_data, mocker,
            get_is_users_can_update_phone_number_details_mock):

        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = True
        storage_mock.get_user_account_details.return_value = user_account_dto
        get_is_users_can_update_phone_number_details_mock.side_effect = \
            base_validator.CustomException(
                exception_type="UPDATE_USER_PHONE_NUMBER_INTERVAL_NOT_COMPLETED",
                message="Update phone number interval not completed")

        with pytest.raises(base_validator.CustomException):
            interactor.update_user_account_phone_number(
                update_user_account_phone_number_dto)

        get_is_users_can_update_phone_number_details_mock.assert_called_once_with(
            user_ids=[user_id])
        storage_mock.create_user_account_phone_number_update_log_details\
            .assert_not_called()

    @freezegun.freeze_time('2022-03-03')
    @override_settings(
        VERIFY_PHONE_NUMBER_OTP_CALL_TEMPLATE='template',
        SWAP_PHONE_NUMBERS_WHILE_UPDATING=False)
    def test_when_user_already_has_verified_update_log_and_completed_interval(
            self, interactor, storage_mock, setup_data, mocker,
            get_is_users_can_update_phone_number_details_mock):
        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        sms_template = \
            OTPMessageFormatConstants.FORMAT_TO_VERIFY_UPDATE_PHONE_NUMBER
        call_template = settings.VERIFY_PHONE_NUMBER_OTP_CALL_TEMPLATE

        user_account_update_phone_details_dto = storage_dtos_factories.\
            UserAccountUpdatePhoneDetailsLogDTOFactory(
                user_id=user_id,
                new_phone_number=phone_number_dto.phone_number,
                new_country_code=phone_number_dto.country_code,
                old_phone_number=user_account_dto.phone_number,
                old_country_code=user_account_dto.country_code,
                failure_remarks=None,
                change_reason=
                update_user_account_phone_number_dto.reason_to_change,
                verification_status=otp_verification_constants.
                VerificationStatus.VERIFICATION_IN_PROGRESS.value
            )
        user_can_update_phone_number_details_dto = UserIdWiseCanUpdatePhoneNumberDetailsDTOFactory(
            user_id=user_id,
            can_update_phone_number=True,
            latest_phone_number_update_datetime=datetime.datetime(2022, 2, 1),
            can_update_phone_number_after_datetime=None)

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = True
        storage_mock.get_user_account_details.return_value = user_account_dto
        get_is_users_can_update_phone_number_details_mock.return_value = [
            user_can_update_phone_number_details_dto]

        send_otp_to_user_phone_number_mock = \
            get_send_otp_to_user_phone_number_mock(mocker)

        interactor.update_user_account_phone_number(
            update_user_account_phone_number_dto)

        storage_mock.create_user_account_phone_number_update_log_details \
            .assert_called_once_with(user_account_update_phone_details_dto)
        send_otp_to_user_phone_number_mock.assert_called_once_with(
                phone_number=phone_number_dto,
                template=sms_template, call_template=call_template,
                send_otp_through=otp_verification_constants.SendOTPThrough.SMS)

    @freezegun.freeze_time('2022-03-03')
    @override_settings(
        VERIFY_PHONE_NUMBER_OTP_CALL_TEMPLATE='template',
        SWAP_PHONE_NUMBERS_WHILE_UPDATING=True)
    def test_when_user_already_has_verified_update_log_and_completed_interval(
            self, interactor, storage_mock, setup_data, mocker,
            get_is_users_can_update_phone_number_details_mock):
        user_id, update_user_account_phone_number_dto, \
            phone_number_dto, user_account_dto = setup_data

        sms_template = \
            OTPMessageFormatConstants.FORMAT_TO_VERIFY_UPDATE_PHONE_NUMBER
        call_template = settings.VERIFY_PHONE_NUMBER_OTP_CALL_TEMPLATE

        user_account_update_phone_details_dto = storage_dtos_factories.\
            UserAccountUpdatePhoneDetailsLogDTOFactory(
                user_id=user_id,
                new_phone_number=phone_number_dto.phone_number,
                new_country_code=phone_number_dto.country_code,
                old_phone_number=user_account_dto.phone_number,
                old_country_code=user_account_dto.country_code,
                failure_remarks=None,
                change_reason=
                update_user_account_phone_number_dto.reason_to_change,
                verification_status=otp_verification_constants.
                VerificationStatus.VERIFICATION_IN_PROGRESS.value
            )
        user_can_update_phone_number_details_dto = UserIdWiseCanUpdatePhoneNumberDetailsDTOFactory(
            user_id=user_id,
            can_update_phone_number=True,
            latest_phone_number_update_datetime=datetime.datetime(2022, 2, 1),
            can_update_phone_number_after_datetime=None)

        get_validate_phone_number_mock(mocker)
        storage_mock.is_user_id_exists.return_value = True
        storage_mock.is_user_account_active.return_value = True
        storage_mock.get_user_account_details.return_value = user_account_dto
        get_is_users_can_update_phone_number_details_mock.return_value = [
            user_can_update_phone_number_details_dto]

        send_otp_to_user_phone_number_mock = \
            get_send_otp_to_user_phone_number_mock(mocker)

        # Act
        interactor.update_user_account_phone_number(
            update_user_account_phone_number_dto)

        # Assert
        storage_mock.create_user_account_phone_number_update_log_details \
            .assert_called_once_with(user_account_update_phone_details_dto)
        send_otp_to_user_phone_number_mock.assert_called_once_with(
                phone_number=phone_number_dto,
                template=sms_template, call_template=call_template,
                send_otp_through=otp_verification_constants.SendOTPThrough.SMS)
        storage_mock.check_user_exists_with_phone_number.assert_not_called()
