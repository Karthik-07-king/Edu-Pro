import mock
import pytest

from ib_users.constants.custom_exception_messages import INVALID_EMAIL, \
    USER_ACCOUNT_IS_DEACTIVATED
from ib_users.exceptions.custom_exception_constants import \
    USER_NEW_EMAIL_IS_SAME_AS_EXISTING_EMAIL
from ib_users.exceptions.registration_exceptions import \
    AccountWithThisEmailAlreadyExistsException
from ib_users.exceptions.user_account_exceptions import InvalidUserIdException
from ib_users.interactors.user_profile_interactor import UserProfileDTO
from ib_users.tests.factories.storage_dtos import UserAccountDTOFactory
from ib_users.validators.base_validator import CustomException


class TestUpdateUserAccountEmailInteractorInteractor:
    @pytest.fixture()
    def user_account_storage(self):
        from ib_users.interactors.storages import UserAccountsStorage
        return mock.create_autospec(UserAccountsStorage)

    @pytest.fixture()
    def user_profile_storage(self):
        from ib_users.interactors.storages.user_profile_storage import UserProfileStorage
        return mock.create_autospec(UserProfileStorage)

    @pytest.fixture
    def interactor(self, user_account_storage, user_profile_storage):
        from ib_users.interactors.update_user_account_email_interactor import \
            UpdateUserAccountEmailInteractorInteractor
        return UpdateUserAccountEmailInteractorInteractor(
            user_account_storage=user_account_storage,
            user_profile_storage=user_profile_storage
        )

    def test_with_invalid_email(self, interactor):
        # Arrange
        user_id = "User1"
        updated_email = "email1"

        # Act
        with pytest.raises(CustomException) as err:
            interactor.update_user_account_email(
                user_id=user_id, updated_email=updated_email
            )
        # Assert
        assert err.value.error_type == INVALID_EMAIL.code

    def test_with_invalid_user_id(self, interactor, user_account_storage):
        # Arrange
        user_id = "User1"
        updated_email = "email1@gmail.com"
        user_account_storage.is_user_id_exists.return_value = False

        # Act
        with pytest.raises(InvalidUserIdException):
            interactor.update_user_account_email(
                user_id=user_id, updated_email=updated_email
            )
        # Assert
        user_account_storage.is_user_id_exists.assert_called_once_with(
            user_id=user_id)

    def test_with_inactive_user(self, interactor, user_account_storage):
        # Arrange
        user_id = "User1"
        updated_email = "email1@gmail.com"
        user_account_storage.is_user_id_exists.return_value = True
        user_account_storage.is_user_account_active.return_value = False

        # Act
        with pytest.raises(CustomException) as err:
            interactor.update_user_account_email(
                user_id=user_id, updated_email=updated_email
            )
        # Assert
        user_account_storage.is_user_id_exists.assert_called_once_with(
            user_id=user_id)
        user_account_storage.is_user_account_active.assert_called_once_with(
            user_id=user_id)
        assert err.value.error_type == USER_ACCOUNT_IS_DEACTIVATED.code

    def test_with_user_email_is_same_as_existing_email(
            self, interactor, user_account_storage):
        # Arrange
        user_id = "User1"
        updated_email = "email1@gmail.com"
        user_account_storage.is_user_id_exists.return_value = True
        user_account_storage.is_user_account_active.return_value = True
        user_account_storage.get_user_account_details.return_value = \
            UserAccountDTOFactory(email=updated_email)

        # Act
        with pytest.raises(CustomException) as err:
            interactor.update_user_account_email(
                user_id=user_id, updated_email=updated_email
            )
        # Assert
        user_account_storage.is_user_id_exists.assert_called_once_with(
            user_id=user_id)
        user_account_storage.is_user_account_active.assert_called_once_with(
            user_id=user_id)
        assert err.value.error_type == USER_NEW_EMAIL_IS_SAME_AS_EXISTING_EMAIL.code

    def test_with_given_email_already_exists_with_another_account(
            self, interactor, user_account_storage):
        # Arrange
        user_id = "User1"
        updated_email = "email1@gmail.com"
        user_account_storage.is_user_id_exists.return_value = True
        user_account_storage.is_user_account_active.return_value = True
        user_account_storage.get_user_account_details.return_value = UserAccountDTOFactory()
        user_account_storage.check_user_exists_with_email.side_effect = \
            AccountWithThisEmailAlreadyExistsException()

        # Act
        with pytest.raises(AccountWithThisEmailAlreadyExistsException):
            interactor.update_user_account_email(
                user_id=user_id, updated_email=updated_email
            )
        # Assert
        user_account_storage.is_user_id_exists.assert_called_once_with(
            user_id=user_id)
        user_account_storage.is_user_account_active.assert_called_once_with(
            user_id=user_id)
        user_account_storage.check_user_exists_with_email.assert_called_once_with(
            email=updated_email)

    def test_with_valid_data(
            self, interactor, user_account_storage, user_profile_storage):
        # Arrange
        user_id = "User1"
        updated_email = "email1@gmail.com"
        user_account_storage.is_user_id_exists.return_value = True
        user_account_storage.is_user_account_active.return_value = True
        user_account_storage.get_user_account_details.return_value = UserAccountDTOFactory()
        user_account_storage.check_user_exists_with_email.return_value = None

        # Act
        interactor.update_user_account_email(
            user_id=user_id, updated_email=updated_email
        )
        # Assert
        user_account_storage.is_user_id_exists.assert_called_once_with(
            user_id=user_id)
        user_account_storage.is_user_account_active.assert_called_once_with(
            user_id=user_id)
        user_account_storage.check_user_exists_with_email.assert_called_once_with(
            email=updated_email)
        user_account_storage.update_email.assert_called_once_with(
            email=updated_email, user_id=user_id)
        user_profile_dto = UserProfileDTO(email=updated_email)
        user_profile_storage.update_user_profile(
            user_id=user_id, update_profile_data=user_profile_dto
        )