import typing

from ib_users.interfaces import dtos as interface_dtos
from ib_users.interactors.storages.user_accounts_storage import UserAccountsStorage
from ib_users.interactors.storages.user_profile_storage import UserProfileStorage
from ib_users.interfaces import enums as interface_enums
from ib_users.constants.user_profile import exception_messages


class CreateOrUpdateUserEducationDetailsInteractor:

    def __init__(self, user_profile_storage: UserProfileStorage,
                 user_account_storage: UserAccountsStorage):
        self.user_profile_storage = user_profile_storage
        self.user_account_storage = user_account_storage

    def create_or_update_user_education_details(
            self, user_education_details: interface_dtos.UpdateUserEducationDetailsDTO):
        self._validate_user_education_details(
            user_education_details=user_education_details)

        user_id = user_education_details.user_id
        ssc_details = user_education_details.ssc_details
        if ssc_details:
            self.user_profile_storage.create_or_update_user_ssc_details(
                user_id=user_id, ssc_details=ssc_details)

        intermediate_details = user_education_details.intermediate_details
        if intermediate_details:
            self.user_profile_storage.create_or_update_user_intermediate_details(
                user_id=user_id, intermediate_details=intermediate_details)

        degree_details = user_education_details.degree_details
        if degree_details:
            self._update_user_degree_details(
                degree_details=degree_details, user_id=user_id)

    def _validate_user_id(self, user_id: str):
        from ib_users.exceptions.user_account_exceptions import \
            InvalidUserIdException

        is_user_id_exists = self.user_account_storage.is_user_id_exists(
            user_id=user_id)
        if not is_user_id_exists:
            raise InvalidUserIdException()

    def _validate_user_education_details(
            self, user_education_details: interface_dtos.UpdateUserEducationDetailsDTO):
        from ib_users.exceptions.user_profile_exceptions import \
            InvalidEducationDetailsException

        self._validate_user_id(user_id=user_education_details.user_id)

        invalid_ssc_details, invalid_intermediate_details, invalid_degree_details = None, None, None
        ssc_details = user_education_details.ssc_details
        if ssc_details:
            invalid_ssc_details = self._get_invalid_ssc_details(ssc_details=ssc_details)

        intermediate_details = user_education_details.intermediate_details
        if intermediate_details:
            invalid_intermediate_details = self._get_invalid_intermediate_details(
                intermediate_details=intermediate_details)

        degree_details = user_education_details.degree_details
        if degree_details:
            invalid_degree_details = self._get_invalid_degree_details(degree_details=degree_details)

        if invalid_ssc_details or invalid_intermediate_details or invalid_degree_details:
            invalid_education_details = interface_dtos.InvalidEducationDetailsDTO(
                ssc_details=invalid_ssc_details,
                intermediate_details=invalid_intermediate_details,
                degree_details=invalid_degree_details)
            raise InvalidEducationDetailsException(
                invalid_education_details=invalid_education_details)

    def _get_invalid_ssc_details(
            self, ssc_details: interface_dtos.UpdateSSCDetailsDTO
            ) -> typing.Optional[interface_dtos.InvalidSSCDetailsDTO]:
        invalid_completion_status_details, invalid_score_type_details, \
            invalid_score_details, invalid_year_of_completion_details, \
            invalid_board_name_enum_details = None, None, None, None, None

        if ssc_details.completion_status:
            invalid_completion_status_details = self._get_invalid_completion_status_details(
                completion_status=ssc_details.completion_status)
        if ssc_details.score_type:
            invalid_score_type_details = self._get_invalid_score_type_details(
                score_type=ssc_details.score_type)
        if ssc_details.score:
            invalid_score_details = self._get_invalid_score_details(
                score=ssc_details.score, score_type=ssc_details.score_type)
        if ssc_details.year_of_completion:
            invalid_year_of_completion_details = self._get_invalid_year_of_completion_details(
                year_of_completion=ssc_details.year_of_completion,
                course_completion_status=ssc_details.completion_status)
        if ssc_details.institute_id:
            self._validate_institute_id(institute_id=ssc_details.institute_id)
        if ssc_details.board_name_enum:
            invalid_board_name_enum_details = self._get_invalid_ssc_board_name_enum_details(
                board_name_enum=ssc_details.board_name_enum)

        if (invalid_completion_status_details or invalid_score_details or
                invalid_score_type_details or invalid_year_of_completion_details or
                invalid_board_name_enum_details):
            return interface_dtos.InvalidSSCDetailsDTO(
                completion_status=invalid_completion_status_details,
                score_type=invalid_score_type_details,
                year_of_completion=invalid_year_of_completion_details,
                score=invalid_score_details,
                board_name_enum=invalid_board_name_enum_details)

    @staticmethod
    def _get_invalid_ssc_board_name_enum_details(
            board_name_enum: interface_enums.SSCBoardName
            ) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        invalid_value_details_dto = None

        valid_board_name_enums = interface_enums.SSCBoardName.get_list_of_values()
        if board_name_enum not in valid_board_name_enums:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=board_name_enum,
                error_code=exception_messages.INVALID_SSC_BOARD_NAME_ENUM[1],
                error_message=exception_messages.INVALID_SSC_BOARD_NAME_ENUM[0])
        return invalid_value_details_dto

    def _get_invalid_intermediate_details(
            self, intermediate_details: interface_dtos.UpdateIntermediateDetailsDTO
            ) -> typing.Optional[interface_dtos.InvalidIntermediateDetailsDTO]:
        invalid_completion_status_details, invalid_score_type_details, \
            invalid_score_details, invalid_year_of_completion_details = None, None, None, None

        if intermediate_details.completion_status:
            invalid_completion_status_details = self._get_invalid_completion_status_details(
                completion_status=intermediate_details.completion_status)
        if intermediate_details.score_type:
            invalid_score_type_details = self._get_invalid_score_type_details(
                score_type=intermediate_details.score_type)
        if intermediate_details.score:
            invalid_score_details = self._get_invalid_score_details(
                score=intermediate_details.score, score_type=intermediate_details.score_type)
        if intermediate_details.year_of_completion:
            invalid_year_of_completion_details = self._get_invalid_year_of_completion_details(
                year_of_completion=intermediate_details.year_of_completion,
                course_completion_status=intermediate_details.completion_status)
        if intermediate_details.institute_id:
            self._validate_institute_id(
                institute_id=intermediate_details.institute_id)
        if intermediate_details.course_id:
            self._validate_course_id(course_id=intermediate_details.course_id)

        if (invalid_completion_status_details or invalid_score_type_details or
                invalid_score_details or invalid_year_of_completion_details):
            return interface_dtos.InvalidIntermediateDetailsDTO(
                completion_status=invalid_completion_status_details,
                score_type=invalid_score_type_details,
                score=invalid_score_details,
                year_of_completion=invalid_year_of_completion_details)

    def _get_invalid_degree_details(
            self, degree_details: typing.List[interface_dtos.UpdateDegreeDetailsDTO]
            ) -> typing.Optional[typing.List[interface_dtos.InvalidDegreeDetailsDTO]]:
        invalid_degree_details = []
        for each_degree_details in degree_details:
            invalid_completion_status_details, invalid_score_type_details, \
                invalid_score_details, invalid_year_of_completion_details, \
                invalid_degree_type_details, invalid_no_of_backlogs_details, \
                invalid_start_year_details, invalid_end_year_details, invalid_degree_type_details = \
                None, None, None, None, None, None, None, None, None
            if each_degree_details.completion_status:
                invalid_completion_status_details = self._get_invalid_completion_status_details(
                    completion_status=each_degree_details.completion_status)
            if each_degree_details.score_type:
                invalid_score_type_details = self._get_invalid_score_type_details(
                    score_type=each_degree_details.score_type)
            if each_degree_details.type:
                invalid_degree_type_details = self._get_invalid_degree_type_details(
                    degree_type=each_degree_details.type)
            if each_degree_details.institute_city_id:
                self._validate_institute_city_id(
                    institute_city_id=each_degree_details.institute_city_id)
            if each_degree_details.department_id:
                self._validate_department_id(department_id=each_degree_details.department_id)
            if each_degree_details.institute_id:
                self._validate_institute_id(institute_id=each_degree_details.institute_id)
            if each_degree_details.course_id:
                self._validate_course_id(course_id=each_degree_details.course_id)
            if each_degree_details.no_of_backlogs and each_degree_details.no_of_backlogs < 0:
                invalid_no_of_backlogs_details = interface_dtos.InvalidValueDetailsDTO(
                    value=each_degree_details.no_of_backlogs,
                    error_code=exception_messages.INVALID_NO_OF_BACKLOGS[1],
                    error_message=exception_messages.INVALID_NO_OF_BACKLOGS[0])
            if each_degree_details.institute_district_id:
                self._validate_institute_district_id(
                    institute_district_id=each_degree_details.institute_district_id)
            if each_degree_details.institute_state_id:
                self._validate_institute_state_id(
                    institute_state_id=each_degree_details.institute_state_id)
            if each_degree_details.start_year:
                invalid_start_year_details = self._get_invalid_start_year_details(
                    start_year=each_degree_details.start_year)
            if each_degree_details.end_year:
                invalid_end_year_details = self._get_invalid_end_year_details(
                    end_year=each_degree_details.end_year, start_year=each_degree_details.start_year)
            if each_degree_details.score:
                invalid_score_details = self._get_invalid_score_details(
                    score=each_degree_details.score, score_type=each_degree_details.score_type)

            if (invalid_completion_status_details or invalid_score_type_details or
                    invalid_score_details or invalid_start_year_details or invalid_end_year_details or
                    invalid_no_of_backlogs_details or invalid_degree_type_details):
                invalid_degree_details.append(
                    interface_dtos.InvalidDegreeDetailsDTO(
                        completion_status=invalid_completion_status_details,
                        score_type=invalid_score_type_details,
                        score=invalid_score_details,
                        start_year=invalid_start_year_details,
                        end_year=invalid_end_year_details,
                        no_of_backlogs=invalid_no_of_backlogs_details,
                        type=invalid_degree_type_details)
                )
        if invalid_degree_details:
            return invalid_degree_details

    @staticmethod
    def _get_invalid_start_year_details(start_year: int) \
            -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        from datetime import datetime

        current_year = datetime.now().year
        if start_year and (start_year < 0 or start_year > current_year):
            return interface_dtos.InvalidValueDetailsDTO(
                value=start_year,
                error_code=exception_messages.INVALID_START_YEAR[1],
                error_message=exception_messages.INVALID_START_YEAR[0])

    @staticmethod
    def _get_invalid_end_year_details(end_year: int, start_year: typing.Optional[int])\
            -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        if end_year and (end_year < 0):
            return interface_dtos.InvalidValueDetailsDTO(
                value=end_year,
                error_code=exception_messages.INVALID_END_YEAR[1],
                error_message=exception_messages.INVALID_END_YEAR[0])
        if start_year and (end_year < start_year):
            return interface_dtos.InvalidValueDetailsDTO(
                value=end_year,
                error_code=exception_messages.END_YEAR_SHOULD_BE_GREATER_THAN_START_YEAR[1],
                error_message=exception_messages.END_YEAR_SHOULD_BE_GREATER_THAN_START_YEAR[0])

    @staticmethod
    def _get_invalid_score_details(
            score: float, score_type: interface_enums.ScoreType)\
            -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        invalid_value_details_dto = None

        if score < 0:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=score,
                error_code=exception_messages.INVALID_SCORE[1],
                error_message=exception_messages.INVALID_SCORE[0])
        elif score_type == interface_enums.ScoreType.CGPA.value and score > 10:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=score,
                error_code=exception_messages.INVALID_SCORE_FOR_CGPA_SCORE_TYPE[1],
                error_message=exception_messages.INVALID_SCORE_FOR_CGPA_SCORE_TYPE[0])
        elif score_type == interface_enums.ScoreType.PERCENTAGE.value and score > 100:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=score,
                error_code=exception_messages.INVALID_SCORE_FOR_PERCENTAGE_SCORE_TYPE[1],
                error_message=exception_messages.INVALID_SCORE_FOR_PERCENTAGE_SCORE_TYPE[0])

        return invalid_value_details_dto

    @staticmethod
    def _get_invalid_year_of_completion_details(
            year_of_completion: int,
            course_completion_status: typing.Optional[interface_enums.CourseCompletionStatus]
            ) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        from datetime import datetime

        invalid_value_details = None
        current_year = datetime.now().year

        if year_of_completion < 0:
            invalid_value_details = interface_dtos.InvalidValueDetailsDTO(
                value=year_of_completion,
                error_code=exception_messages.INVALID_YEAR_OF_COMPLETION[1],
                error_message=exception_messages.INVALID_YEAR_OF_COMPLETION[0]
            )
        if course_completion_status and course_completion_status in [
                interface_enums.CourseCompletionStatus.COMPLETED.value,
                interface_enums.CourseCompletionStatus.DISCONTINUED.value] and \
                year_of_completion > current_year:
            invalid_value_details = interface_dtos.InvalidValueDetailsDTO(
                value=year_of_completion,
                error_code=exception_messages.INVALID_YEAR_OF_COMPLETION[1],
                error_message=exception_messages.INVALID_YEAR_OF_COMPLETION[0]
            )
        return invalid_value_details

    @staticmethod
    def _get_invalid_completion_status_details(
            completion_status: interface_enums.CourseCompletionStatus
            ) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        invalid_value_details_dto = None

        valid_completion_statuses = interface_enums.CourseCompletionStatus.get_list_of_values()
        if completion_status not in valid_completion_statuses:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=completion_status,
                error_code=exception_messages.INVALID_COURSE_COMPLETION_STATUS[1],
                error_message=exception_messages.INVALID_COURSE_COMPLETION_STATUS[0])
        return invalid_value_details_dto

    @staticmethod
    def _get_invalid_score_type_details(
            score_type: interface_enums.ScoreType) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        invalid_value_details_dto = None

        valid_score_types = interface_enums.ScoreType.get_list_of_values()
        if score_type not in valid_score_types:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=score_type,
                error_code=exception_messages.INVALID_SCORE_TYPE[1],
                error_message=exception_messages.INVALID_SCORE_TYPE[0])
        return invalid_value_details_dto

    @staticmethod
    def _get_invalid_degree_type_details(
            degree_type: interface_enums.DegreeType
            ) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        invalid_value_details_dto = None

        valid_degree_types = interface_enums.DegreeType.get_list_of_values()
        if degree_type not in valid_degree_types:
            invalid_value_details_dto = interface_dtos.InvalidValueDetailsDTO(
                value=degree_type,
                error_code=exception_messages.INVALID_DEGREE_TYPE[1],
                error_message=exception_messages.INVALID_DEGREE_TYPE[0])
        return invalid_value_details_dto

    def _validate_institute_district_id(self, institute_district_id: str):
        # TODO: Add institute_district_id validation
        pass

    def _validate_institute_state_id(self, institute_state_id: str):
        # TODO: Add institute_id validation
        pass

    def _validate_institute_id(self, institute_id: str):
        # TODO: Add institute_id validation
        pass

    def _validate_department_id(self, department_id: str):
        # TODO: Add department_id validation
        pass

    def _validate_course_id(self, course_id: str):
        # TODO: Add course_id validation
        pass

    def _validate_institute_city_id(self, institute_city_id: str):
        # TODO: Add institute_city_id validation
        pass

    def _update_user_degree_details(
            self, degree_details:
            typing.List[interface_dtos.UpdateDegreeDetailsDTO], user_id: str):
        from collections import defaultdict
        from ib_users.exceptions.user_profile_exceptions import \
            InvalidUserDegreeDetailsIdsException

        user_existing_degree_details = self.user_profile_storage. \
            get_user_degree_details(user_id=user_id)
        existing_user_degree_details_ids = [
            each.id for each in user_existing_degree_details]
        given_user_degree_details_ids = [
            each.id for each in degree_details if each.id]

        invalid_degree_details_ids = list(set(given_user_degree_details_ids) - set(
            existing_user_degree_details_ids))
        if invalid_degree_details_ids:
            raise InvalidUserDegreeDetailsIdsException(
                degree_details_ids=invalid_degree_details_ids)

        degree_details_id_wise_given_degree_details = {
            each.id: each for each in degree_details}
        degree_type_wise_given_degree_details = defaultdict(list)
        for each in degree_details:
            degree_type_wise_given_degree_details[each.type].append(each)

        degree_type_wise_existing_degree_details = defaultdict(list)
        for each in user_existing_degree_details:
            degree_type_wise_existing_degree_details[each.type].append(each)

        user_degree_details_to_update, user_degree_details_ids_to_delete = [], []
        for degree_type, existing_degree_details in degree_type_wise_existing_degree_details.items():
            given_degree_details = degree_type_wise_given_degree_details.get(degree_type, [])
            if given_degree_details:
                for each in existing_degree_details:
                    degree_details_dto = degree_details_id_wise_given_degree_details.get(each.id)
                    if degree_details_dto:
                        user_degree_details_to_update.append(degree_details_dto)
                    else:
                        user_degree_details_ids_to_delete.append(each.id)

        user_degree_details_to_create = []
        for each in degree_details:
            if each.id is None:
                user_degree_details_to_create.append(each)

        if user_degree_details_ids_to_delete:
            self.user_profile_storage.delete_user_degree_details(
                degree_details_ids=user_degree_details_ids_to_delete)
        if user_degree_details_to_update:
            self.user_profile_storage.update_user_degree_details(
                degree_details=user_degree_details_to_update)
        if user_degree_details_to_create:
            self.user_profile_storage.create_user_degree_details(
                user_id=user_id, degree_details=user_degree_details_to_create)
