import typing

from ib_users.constants.user_profile.constants import NOT_GIVEN_DTO_VALUE
from ib_users.interactors.storages.dtos import ProfileDetailsDTO
from ib_users.interfaces import dtos as interface_dtos, enums
from ib_users.interactors.storages.user_accounts_storage import UserAccountsStorage
from ib_users.interactors.storages.user_profile_storage import UserProfileStorage
from ib_users.constants.user_profile import exception_messages


class CreateOrUpdateUserProfileDetailsInteractor:

    def __init__(self, user_profile_storage: UserProfileStorage,
                 user_account_storage: UserAccountsStorage):
        self.user_profile_storage = user_profile_storage
        self.user_account_storage = user_account_storage

    def create_or_update_user_profile_details(
            self, user_profile_details: interface_dtos.UpdateUserProfileDetailsDTO):
        self._validate_user_profile_details(
            user_profile_details=user_profile_details)

        user_id = user_profile_details.user_id
        profile_details = user_profile_details.profile_details
        if profile_details != NOT_GIVEN_DTO_VALUE:
            existing_user_profile = self._get_existing_user_profile_details(
                user_id=user_id)
            if existing_user_profile:
                profile_details = self._get_profile_details_to_update(
                    existing_user_profile=existing_user_profile,
                    profile_details=profile_details)
            else:
                profile_details = self._get_profile_details_to_create(
                    profile_details=profile_details)
            self.user_profile_storage.create_or_update_user_profile_details(
                user_id=user_id, profile_details=profile_details)
            if profile_details.preferred_languages != NOT_GIVEN_DTO_VALUE:
                self.user_profile_storage.update_user_preferred_languages(
                    user_id=user_id,
                    preferred_languages=profile_details.preferred_languages)
            user_details = self.user_account_storage.get_user_account_details(
                user_id=user_id)
            if user_details.email != profile_details.email:
                self.user_profile_storage.update_is_email_verified(
                    user_id=user_id, is_email_verified=False)
                self.user_account_storage.update_email(user_id=user_id, email=None)

        contact_details = user_profile_details.contact_details
        if contact_details != NOT_GIVEN_DTO_VALUE:
            if contact_details.whatsapp_mobile_number and contact_details.whatsapp_mobile_country_code:
                contact_details.have_whatsapp = True
            self.user_profile_storage.create_or_update_user_contact_details(
                user_id=user_id, contact_details=contact_details)

        social_profile_details = user_profile_details.social_profile_details
        if social_profile_details != NOT_GIVEN_DTO_VALUE:
            self._update_user_social_profile_details(
                social_profile_details=social_profile_details,
                user_id=user_id)

    def _validate_user_profile_details(
            self, user_profile_details: interface_dtos.UpdateUserProfileDetailsDTO):
        from ib_users.exceptions.user_profile_exceptions import \
            InvalidUserProfileDetailsException
        user_id = user_profile_details.user_id
        self._validate_user_id(user_id=user_id)

        profile_details = user_profile_details.profile_details
        invalid_profile_details = None
        if profile_details != NOT_GIVEN_DTO_VALUE:
            invalid_profile_details = self._get_invalid_profile_details(
                profile_details=profile_details, user_id=user_id)

        invalid_contact_details = None
        contact_details = user_profile_details.contact_details
        if contact_details != NOT_GIVEN_DTO_VALUE:
            invalid_contact_details = self._get_invalid_contact_details(contact_details=contact_details)
        invalid_social_profile_details = None
        social_profile_details = user_profile_details.social_profile_details
        if social_profile_details != NOT_GIVEN_DTO_VALUE:
            invalid_social_profile_details = self._get_invalid_social_providers_details(
                social_profile_details=social_profile_details)

        if invalid_social_profile_details or invalid_profile_details or \
                invalid_contact_details:
            invalid_profile_details = interface_dtos.InvalidUpdateUserProfileDetailsDTO(
                profile_details=invalid_profile_details,
                contact_details=invalid_contact_details,
                social_profile_details=invalid_social_profile_details)

            raise InvalidUserProfileDetailsException(invalid_profile_details=invalid_profile_details)

    def _get_invalid_social_providers_details(
            self, social_profile_details: typing.List[interface_dtos.SocialProfileDetailsDTO]
            ) -> typing.Optional[typing.List[interface_dtos.InvalidSocialProfileDetailsDTO]]:
        from ib_users.constants.user_profile.exception_messages import \
            INVALID_SOCIAL_PROVIDERS

        invalid_social_provider_details = []
        for each_social_provider in social_profile_details:
            invalid_social_provider = None
            if each_social_provider.social_provider and each_social_provider.social_provider not in \
                    enums.SocialProvider.get_list_of_values():
                invalid_social_provider = interface_dtos.InvalidValueDetailsDTO(
                    value=each_social_provider.social_provider,
                    error_code=INVALID_SOCIAL_PROVIDERS[1],
                    error_message=INVALID_SOCIAL_PROVIDERS[0])
            invalid_profile_link_details = None
            if each_social_provider.profile_link:
                invalid_profile_link_details = self._get_invalid_social_provider_profile_link_details(
                    social_provider=each_social_provider.social_provider,
                    profile_link=each_social_provider.profile_link)

            if invalid_social_provider or invalid_profile_link_details:
                invalid_social_provider_details.append(
                    interface_dtos.InvalidSocialProfileDetailsDTO(
                        social_provider=invalid_social_provider,
                        profile_link=invalid_profile_link_details))
        if invalid_social_provider_details:
            return invalid_social_provider_details

    @staticmethod
    def _get_invalid_social_provider_profile_link_details(
            social_provider: typing.Optional[enums.SocialProvider],
            profile_link: str) -> typing.Optional[interface_dtos.InvalidValueDetailsDTO]:
        import re
        from ib_users.constants.config import LINKEDIN_PROFILE_LINK_REGEX, \
            TWITTER_PROFILE_LINK_REGEX

        invalid_profile_link_details = None
        if social_provider and social_provider == enums.SocialProvider.LINKEDIN.value:
            if not re.match(pattern=LINKEDIN_PROFILE_LINK_REGEX, string=profile_link):
                invalid_profile_link_details = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_link,
                    error_code=exception_messages.INVALID_LINKED_PROFILE_LINK[1],
                    error_message=exception_messages.INVALID_LINKED_PROFILE_LINK[0])
        elif social_provider and social_provider == enums.SocialProvider.TWITTER.value:
            if not re.match(pattern=TWITTER_PROFILE_LINK_REGEX, string=profile_link):
                invalid_profile_link_details = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_link,
                    error_code=exception_messages.INVALID_TWITTER_PROFILE_LINK[1],
                    error_message=exception_messages.INVALID_TWITTER_PROFILE_LINK[0])
        return invalid_profile_link_details

    def _validate_user_id(self, user_id: str):
        from ib_users.exceptions.user_account_exceptions import \
            InvalidUserIdException

        is_user_id_exists = self.user_account_storage.is_user_id_exists(
            user_id=user_id)
        if not is_user_id_exists:
            raise InvalidUserIdException()

    def _get_invalid_profile_details(
            self, profile_details: interface_dtos.UpdateProfileDetailsDTO,
            user_id: str):
        from ib_users.exceptions.invalid_gender_exception import InvalidGenderException
        from ib_users.exceptions.invalid_email_exception import InvalidEmailException
        from ib_users.exceptions.invalid_dob_exception import InvalidDOBException
        from ib_users.interactors.exceptions.user_profile import \
            EmailAlreadyLinkedException
        from ib_users.validators.dob_validator import DOBValidator
        from ib_users.validators.gender_validator import GenderValidator

        preferred_languages = profile_details.preferred_languages
        invalid_preferred_language = None
        if preferred_languages != NOT_GIVEN_DTO_VALUE:
            invalid_preferred_language = self._get_invalid_preferred_languages(
                preferred_languages=preferred_languages)

        invalid_gender_value = None
        if self._should_validate_given_value(profile_details.gender):
            try:
                GenderValidator.validate(value=profile_details.gender)
            except InvalidGenderException as err:
                invalid_gender_value = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_details.gender,
                    error_message=err.error_message,
                    error_code=err.error_type)

        invalid_dob_value = None
        if self._should_validate_given_value(profile_details.date_of_birth):
            try:
                DOBValidator.validate(value=profile_details.date_of_birth)
                self._validate_date_of_birth(date_of_birth=profile_details.date_of_birth)
            except InvalidDOBException as err:
                invalid_dob_value = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_details.date_of_birth,
                    error_message=err.error_message,
                    error_code=err.error_type)

        invalid_email_value = None
        if self._should_validate_given_value(profile_details.email):
            try:
                self._validate_email(email=profile_details.email)
            except InvalidEmailException as err:
                invalid_email_value = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_details.email,
                    error_message=err.error_message,
                    error_code=err.error_type)
            try:
                self._check_email_used_for_another_account(
                    email=profile_details.email, accounts_storage=self.user_account_storage,
                    user_id=user_id)
            except EmailAlreadyLinkedException as err:
                invalid_email_value = interface_dtos.InvalidValueDetailsDTO(
                    value=profile_details.email,
                    error_message=err.error_message,
                    error_code=err.error_type)

        if (invalid_preferred_language or invalid_gender_value or
                invalid_email_value or invalid_dob_value):
            return interface_dtos.InvalidProfileDetailsDTO(
                email=invalid_email_value,
                date_of_birth=invalid_dob_value,
                preferred_languages=invalid_preferred_language,
                gender=invalid_gender_value)

    @staticmethod
    def _get_date_object(value: str):
        from ib_common.date_time_utils.convert_string_to_local_date_time import \
            convert_string_to_local_date_time
        from ib_users.constants.config import DEFAULT_DATE_FORMAT

        datetime_obj = convert_string_to_local_date_time(
            string=value, format_=DEFAULT_DATE_FORMAT)
        return datetime_obj.date()

    def _validate_date_of_birth(self, date_of_birth: str):
        from ib_common.date_time_utils.get_current_local_date_time import \
            get_current_local_date_time
        from ib_users.constants.user_profile import exception_messages
        from ib_users.exceptions.invalid_dob_exception import InvalidDOBException

        current_date = get_current_local_date_time().date()
        given_date = self._get_date_object(date_of_birth)
        if given_date > current_date:
            raise InvalidDOBException(
                exception_type=exception_messages.DATE_OF_BIRTH_SHOULD_BE_LESS_THAN_CURRENT_DATE[1],
                message=exception_messages.DATE_OF_BIRTH_SHOULD_BE_LESS_THAN_CURRENT_DATE[0])

    @staticmethod
    def _get_invalid_preferred_languages(
            preferred_languages: typing.List[enums.Language]):
        from ib_users.constants.user_profile.exception_messages import \
            INVALID_PREFERRED_LANGUAGES

        valid_preferred_languages = enums.Language.get_list_of_values()
        invalid_preferred_languages = list(
            set(preferred_languages) - set(valid_preferred_languages))
        if invalid_preferred_languages:

            return interface_dtos.InvalidValueDetailsDTO(
                value=invalid_preferred_languages,
                error_message=INVALID_PREFERRED_LANGUAGES[0],
                error_code=INVALID_PREFERRED_LANGUAGES[1]
            )

    @staticmethod
    def _validate_email(email: str):
        from ib_users.validators.email_validator import EmailValidator
        from ib_users.exceptions.invalid_email_exception import \
            InvalidEmailException
        from ib_users.constants.custom_exception_messages import INVALID_EMAIL
        from ib_users.validators.base_validator import CustomException

        try:
            EmailValidator.validate(value=email)
        except CustomException:
            raise InvalidEmailException(
                message=INVALID_EMAIL.message, exception_type=INVALID_EMAIL.code)

    @staticmethod
    def _check_email_used_for_another_account(
            email: str, accounts_storage: UserAccountsStorage, user_id: str):
        from ib_users.constants.custom_exception_messages import \
            EMAIL_ALREADY_IN_USE
        from ib_users.interactors.exceptions.user_profile import \
            EmailAlreadyLinkedException
        from ib_users.interactors.exceptions.user_credentials_exceptions import \
            AccountWithEmailDoesntExistException

        try:
            existing_user_id = accounts_storage.get_existing_user_id_given_email(
                email=email)
            if existing_user_id != user_id:
                raise EmailAlreadyLinkedException(
                    message=EMAIL_ALREADY_IN_USE.message,
                    exception_type=EMAIL_ALREADY_IN_USE.code)
        except AccountWithEmailDoesntExistException:
            pass

    @staticmethod
    def _get_invalid_contact_details(
            contact_details: interface_dtos.ContactDetailsDTO):
        from ib_users.constants.user_profile.exception_messages import \
            INVALID_WHATSAPP_MOBILE_NUMBER
        from ib_users.interactors.storages.user_accounts_storage import \
            PhoneNumberDTO
        from ib_users.validators.phone_number_validator_impl import \
            PhoneNumberValidatorImpl

        if contact_details.whatsapp_mobile_number and contact_details.whatsapp_mobile_country_code:
            phone_number_dto = PhoneNumberDTO(
                country_code=contact_details.whatsapp_mobile_country_code,
                phone_number=contact_details.whatsapp_mobile_number)
            phone_number_validator = PhoneNumberValidatorImpl()
            invalid_whatsapp_mobile_number = None
            try:
                phone_number_validator.validate(phone_number_DTO=phone_number_dto)
            except Exception:
                invalid_whatsapp_mobile_number = interface_dtos.InvalidValueDetailsDTO(
                        value=contact_details.whatsapp_mobile_number,
                        error_code=INVALID_WHATSAPP_MOBILE_NUMBER[1],
                        error_message=INVALID_WHATSAPP_MOBILE_NUMBER[0])
            if invalid_whatsapp_mobile_number:
                return interface_dtos.InvalidContactDetailsDTO(
                    whatsapp_mobile_number=invalid_whatsapp_mobile_number)

    def _update_user_social_profile_details(
            self, social_profile_details: typing.List[interface_dtos.SocialProfileDetailsDTO],
            user_id: str):
        from ib_users.exceptions.user_profile_exceptions import \
            InvalidUserSocialProfileIdsException

        user_social_profile_details = self.user_profile_storage. \
            get_user_social_profile_details(user_id=user_id)
        existing_user_social_profile_ids = [
            each.id for each in user_social_profile_details]
        given_user_social_profile_ids_to_update = [
            each.id for each in social_profile_details if each.id]

        invalid_social_profile_ids = list(set(given_user_social_profile_ids_to_update) - set(
            existing_user_social_profile_ids))
        if invalid_social_profile_ids:
            raise InvalidUserSocialProfileIdsException(
                social_profile_ids=invalid_social_profile_ids)

        user_social_profile_details_to_update = []
        user_social_profile_ids_to_delete = []
        social_profile_id_wise_given_social_profile_details = {
            each.id: each for each in social_profile_details}

        for each in user_social_profile_details:
            social_profile_details_dto = \
                social_profile_id_wise_given_social_profile_details.get(each.id)
            if social_profile_details_dto:
                user_social_profile_details_to_update.append(social_profile_details_dto)
            else:
                user_social_profile_ids_to_delete.append(each.id)

        user_social_profile_details_to_create = []
        for each in social_profile_details:
            if each.id is None:
                user_social_profile_details_to_create.append(each)

        if user_social_profile_ids_to_delete:
            self.user_profile_storage.delete_user_social_profile_details(
                social_profile_details_ids=user_social_profile_ids_to_delete)

        if user_social_profile_details_to_update:
            self.user_profile_storage.update_social_profile_details(
                social_profile_details=user_social_profile_details_to_update)

        if user_social_profile_details_to_create:
            self.user_profile_storage.create_user_social_profile_details(
                user_id=user_id,
                social_profile_details=user_social_profile_details_to_create)

    def _get_existing_user_profile_details(
            self, user_id: str) -> typing.Optional[ProfileDetailsDTO]:
        from ib_users.exceptions.user_profile_exceptions import \
            UserProfileDetailsDoesNotExistException
        try:
            existing_user_profile = self.user_profile_storage.get_user_profile_details(
                user_id=user_id)
        except UserProfileDetailsDoesNotExistException:
            existing_user_profile = None

        return existing_user_profile

    @staticmethod
    def _get_profile_details_to_update(
            existing_user_profile: ProfileDetailsDTO,
            profile_details: interface_dtos.UpdateProfileDetailsDTO):
        
        if profile_details.first_name == NOT_GIVEN_DTO_VALUE:
            profile_details.first_name = existing_user_profile.first_name
        if profile_details.last_name == NOT_GIVEN_DTO_VALUE:
            profile_details.last_name = existing_user_profile.last_name
        if profile_details.email == NOT_GIVEN_DTO_VALUE:
            profile_details.email = existing_user_profile.email
        if profile_details.gender == NOT_GIVEN_DTO_VALUE:
            profile_details.gender = existing_user_profile.gender
        if profile_details.date_of_birth == NOT_GIVEN_DTO_VALUE:
            profile_details.date_of_birth = existing_user_profile.date_of_birth
        if profile_details.profile_pic_url == NOT_GIVEN_DTO_VALUE:
            profile_details.profile_pic_url = existing_user_profile.profile_pic_url
        if profile_details.cover_page_url == NOT_GIVEN_DTO_VALUE:
            profile_details.cover_page_url = existing_user_profile.cover_page_url
        
        return profile_details

    @staticmethod
    def _get_profile_details_to_create(
            profile_details: interface_dtos.UpdateProfileDetailsDTO):
        if profile_details.first_name == NOT_GIVEN_DTO_VALUE:
            profile_details.first_name = None
        if profile_details.last_name == NOT_GIVEN_DTO_VALUE:
            profile_details.last_name = None
        if profile_details.email == NOT_GIVEN_DTO_VALUE:
            profile_details.email = None
        if profile_details.gender == NOT_GIVEN_DTO_VALUE:
            profile_details.gender = None
        if profile_details.date_of_birth == NOT_GIVEN_DTO_VALUE:
            profile_details.date_of_birth = None
        if profile_details.profile_pic_url == NOT_GIVEN_DTO_VALUE:
            profile_details.profile_pic_url = None
        if profile_details.cover_page_url == NOT_GIVEN_DTO_VALUE:
            profile_details.cover_page_url = None
        
        return profile_details

    @staticmethod
    def _should_validate_given_value(value: typing.Any) -> bool:
        return value is not None and value != NOT_GIVEN_DTO_VALUE
