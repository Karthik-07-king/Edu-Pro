import json
import os
import shutil
from io import open

from dsu.runtime.constants.exceptions.bad_request import BadRequest
from dsu.test_cases.generators.test_case_generator import TestCaseGenerator


class Build(object):
    spec_json = None
    parser = None
    paths = dict()

    def __init__(self, app_name, base_dir, settings=None,
                 is_validation_required=True):
        self.app_name = app_name
        self.base_dir = base_dir
        self.settings = settings
        self.initiate_build(is_validation_required)

    def initiate_build(self, is_validation_required=True):
        # setup build specific paths
        self.setup_paths()

        # create settings file if not exists
        self.check_create_settings_file()

        # step1 check build dir exists
        # self.check_build_exists()

        # step3 validate specs_json
        if is_validation_required:
            # step2 load api_spec.json into spec_json
            self.load_spec_file(self.paths["api_specs_json"])

            self.validate_swagger()

        # step4 custom spec validation
        self.custom_spec_validator()

        # step5 parser swagger specs
        self.parse_swagger_specs()

    def setup_paths(self):
        """
        defines paths used in the project
        :return:
        """
        # TODO: separate out paths based on android, json patch, server_gen.
        app_base_path = os.path.join(self.base_dir, self.app_name)
        build_dir = os.path.join(app_base_path, "build")
        api_spec_dir = os.path.join(app_base_path, "api_specs")
        api_spec_migrations_dir = os.path.join(api_spec_dir, "migrations")
        api_specs_json = os.path.join(api_spec_dir, "api_spec.json")
        request_response_dir = os.path.join(build_dir, "request_response")
        decorator_options_file = os.path.join(request_response_dir,
                                              "decorator_options.py")
        security_definitions_file = os.path.join(request_response_dir,
                                                 "security_definitions.py")
        serializers_base_dir = os.path.join(build_dir, "serializers")
        definitions_serializers_base_dir = os.path.join(serializers_base_dir,
                                                        "definitions")
        global_parameters_dir = os.path.join(build_dir, "parameters")
        global_response_dir = os.path.join(build_dir, "responses")
        url_file = os.path.join(build_dir, "urls.py")
        url_v2_file = os.path.join(build_dir, "urls_v2.py")
        mobx_base_dir = os.path.join(build_dir, "mobx_classes")
        mobx_base_dir_models = os.path.join(mobx_base_dir, 'models')
        mobx_base_dir_responses = os.path.join(mobx_base_dir, 'responses')
        mobx_base_dir_endpoints = os.path.join(mobx_base_dir, 'endpoints')
        mobx_base_dir_parameters = os.path.join(mobx_base_dir, 'parameters')
        view_environments_dir = os.path.join(build_dir, "view_environments")
        sample_json_dir = os.path.join(app_base_path, "conf", "responses")
        settings_file = os.path.join(app_base_path, "conf", "settings.py")
        mock_views_dir = os.path.join(build_dir, "mock_views")
        views_dir = os.path.join(app_base_path, "views")
        api_environment_file = os.path.join(api_spec_dir, "api_environment.py")
        android_base_dir = os.path.join(build_dir,
                                        "android_%s" % self.app_name)
        api_doc_dir = os.path.join(build_dir, "docs")
        tests_dir = os.path.join(app_base_path, "tests")
        global_jars_dir = os.path.join(self.base_dir, "android_jars")
        zappa_settings = os.path.join(self.base_dir, "zappa_settings.json")
        apidoc = os.path.join(self.base_dir, "apidoc.json")
        docs = os.path.join(self.base_dir, "docs")
        static = os.path.join(self.base_dir, "static")
        static_docs = os.path.join(static, "docs")
        interface_dir = os.path.join(app_base_path, 'interfaces')
        service_interface_path = os.path.join(interface_dir, self.app_name
                                              + '_service_interface.py')
        client_app_base_path = app_base_path + "_client"
        client_interface_path = os.path.join(client_app_base_path,
                                             'interface.py')
        client_api_client_path = os.path.join(client_app_base_path,
                                              'api_client.py')
        client_constants_path = os.path.join(client_app_base_path,
                                             'constants.py')
        client_app_init_file = os.path.join(client_app_base_path, '__init__.py')
        base_app_init_file = os.path.join(app_base_path, '__init__.py')

        client_setup_py_path = os.path.join(self.base_dir, "setup.py")
        client_manifest_path = os.path.join(self.base_dir, "MANIFEST.in")
        client_app_base_path_egg_info = client_app_base_path + ".egg-info"
        pypi_dist_path = os.path.join(self.base_dir, "dist")
        package_json = os.path.join(self.base_dir, "package.json")
        docs_html_dir = os.path.join(app_base_path, "docs_html")
        md_file_name = os.path.join(docs_html_dir, "docs.md")
        utils_dir = os.path.join(app_base_path, "constants")
        const_file_name = os.path.join(utils_dir, "generated_enums.py")
        self.paths = {
            "base_dir": self.base_dir,
            "app_base_path": app_base_path,
            "build_dir": build_dir,
            "api_spec_dir": api_spec_dir,
            "api_spec_migrations_dir": api_spec_migrations_dir,
            "api_specs_json": api_specs_json,
            "request_response_dir": request_response_dir,
            "decorator_options_file": decorator_options_file,
            "security_definitions_file": security_definitions_file,
            "serializers_base_dir": serializers_base_dir,
            "definitions_serializers_base_dir": definitions_serializers_base_dir,
            "global_parameters_dir": global_parameters_dir,
            "global_response_dir": global_response_dir,
            "url_file": url_file,
            "url_v2_file": url_v2_file,
            "view_environments_dir": view_environments_dir,
            "sample_json_dir": sample_json_dir,
            "settings_file": settings_file,
            "mock_views_dir": mock_views_dir,
            "views_dir": views_dir,
            "api_environment_file": api_environment_file,
            "android_base_dir": android_base_dir,
            "api_doc_dir": api_doc_dir,
            "tests_dir": tests_dir,
            "global_jars_dir": global_jars_dir,
            "zappa_settings": zappa_settings,
            "apidoc": apidoc,
            "static": static,
            "static_docs": static_docs,
            "docs": docs,
            "interface_dir": interface_dir,
            "service_interface_path": service_interface_path,
            "client_app_base_path": client_app_base_path,
            "client_interface_path": client_interface_path,
            "client_api_client_path": client_api_client_path,
            "client_setup_py_path": client_setup_py_path,
            "client_app_base_path_egg_info": client_app_base_path_egg_info,
            "client_manifest_path": client_manifest_path,
            "client_app_init_file": client_app_init_file,
            "client_constants_path": client_constants_path,
            "base_app_init_file": base_app_init_file,
            "pypi_dist_path": pypi_dist_path,
            "mobx_base_dir": mobx_base_dir,
            'mobx_base_dir_models': mobx_base_dir_models,
            'mobx_base_dir_responses': mobx_base_dir_responses,
            'mobx_base_dir_endpoints': mobx_base_dir_endpoints,
            'mobx_base_dir_parameters': mobx_base_dir_parameters,
            "package_json": package_json,
            "docs_html_dir": docs_html_dir,
            "md_file_name": md_file_name,
            "const_file_name": const_file_name
        }

    def check_create_settings_file(self):
        """
        checks if settings file is present else writes app name to settings file
        :return:
        """
        path = self.paths["settings_file"]
        from dsu.utils.check_path_exists import \
            check_path_exists
        settings_file = check_path_exists(path)
        if not settings_file:
            settings_file_contents = "# '%s' settings" % self.app_name
            from dsu.utils.write_to_file import \
                write_to_file
            write_to_file(settings_file_contents, path)

    def load_spec_file(self, spec_file):
        """
            forms a dict from json and raises exception if not present
        :param spec_file:
        :return:
        """
        from dsu.utils.check_path_exists import \
            check_path_exists
        spec_file_path = check_path_exists(spec_file)
        # print spec_file_path, spec_file,  self.app_name
        if not spec_file_path:
            raise Exception("%s missing" % spec_file)
        with open(spec_file) as f:
            json_text = f.read()
            try:
                self.spec_json = json.loads(json_text)
            except ValueError:
                print("The \"%s/api_specs/api_spec.json\" is not a proper JSON." % self.app_name)
                exit(1)

    def validate_swagger(self):
        from swagger_spec_validator.util import get_validator
        validator = get_validator(self.spec_json)
        validator.validate_spec(self.spec_json, spec_url='')

    def custom_spec_validator(self):
        # todo need to check for unsupported features present in the specs_json

        # content-type "application/json", "application/x-www-form-urlencoded", -- multipart/form-data not supported
        # parameter type "formData" not supported
        # custom header parameter name does not match standard http request / response headers
        # path parameters regex must be single group
        # file - parameter types not supported
        # path param value must be single word, no spaces allowed in param name
        # python keywords as key / properties names
        # allOff not supported yet
        # response headers - to _ convertion, naming convertion
        # not allowing 'default' key as response method
        self._validate_group_names_and_operation_ids()
        pass

    def _validate_group_names_and_operation_ids(self):
        paths = self.spec_json['paths']

        operation_ids = list()
        group_names = list()
        for path, path_dict in paths.items():
            for method, method_dict in path_dict.items():
                if method in ["get", "put", "post", "delete", "options",
                              "head", "patch"]:
                    operation_ids.append(method_dict['operationId'])
                    if method_dict.get('x-group', ''):
                        group_names.append(method_dict['x-group'])

        for group_name in group_names:
            for operation_id in operation_ids:
                if group_name == operation_id:
                    raise BadRequest(
                        "group name and operation_id can not be same")

    def parse_swagger_specs(self):
        from dsu.dsu_gen.openapi.generator.swagger_parser import \
            SwaggerParser
        self.parser = SwaggerParser(spec_json=self.spec_json)

    def generate_specs_build(self):
        """
        generates the elements present in spec file
        :return:
        """
        from dsu.dsu_gen.openapi.generator.swagger_generator import \
            SwaggerGenerator

        swagger_gen = SwaggerGenerator(self.parser, self.paths, self.app_name)
        # generating request_response files
        swagger_gen.generate_request_response()
        # testing properties
        swagger_gen.generate_definitions()
        # generating global parameters
        swagger_gen.generate_parameters()
        # generating global response
        swagger_gen.generate_responses()
        # generating urls
        swagger_gen.generate_urls()

        self.generate_apis_test_cases()

    def generate_apis_test_cases(self):
        """
        generates the test cases in spec file
        :return:
        """

        for path_name, path in list(self.parser.paths().items()):

            group_name = ''
            tags = []

            for method, value in list(path.items()):
                if method in ('get', 'post', 'put', 'delete'):
                    for tag in value.get('tags', []):
                        tags.append(tag)
                    if value.get('x-group'):
                        group_name = value.get('x-group')

                test_case_generator = TestCaseGenerator(
                    parser=self.parser,
                    dir_paths=self.paths,
                    app_name=self.app_name,
                    group_name=group_name,
                    path=path,
                    path_name=path_name
                )
                test_case_generator.generate_apis_testcases()

    def generate_test_case(self, operation_id, tcn, snapshot=False):
        is_found = False
        for path_name, path in list(self.parser.paths().items()):
            self.path_name = path_name
            test_case_generator = TestCaseGenerator(
                parser=self.parser,
                dir_paths=self.paths,
                app_name=self.app_name,
                path=path,
                path_name=path_name
            )
            is_found = test_case_generator.generate_new_testcase(
                operation_id, tcn, path, path_name, snapshot=snapshot)
            if is_found:
                return

        if not is_found:
            from colored import fg, attr
            print(
                '{}{}{}\'{}\' not found in apps. Please provide correct operation id.'.format(
                    fg(1), attr(1), attr(4), operation_id))

    def clean(self):
        """
        deletes the build and docs
        :return:
        """
        if os.path.exists(self.paths['build_dir']):
            shutil.rmtree(self.paths['build_dir'])
        if os.path.exists(os.path.join(self.base_dir, 'docs')):
            shutil.rmtree(os.path.join(self.base_dir, 'docs'))
        os.system("find . -name \*.pyc -delete")

    @property
    def swagger_generator(self):
        from dsu.dsu_gen.openapi.generator.swagger_generator import \
            SwaggerGenerator
        swagger_gen = SwaggerGenerator(self.parser, self.paths, self.app_name)
        return swagger_gen

