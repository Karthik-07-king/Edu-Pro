import uuid
from typing import List, Dict

from ib_notifications.constants.enums import DeviceType
from ib_notifications.dtos.cm_token_with_user_id_dto import \
    UserIdWithCMToken
from ib_notifications.dtos.notification_message_dto import \
    NotificationMessageDTO
from ib_notifications.dtos.user_ids_with_no_cm_token import \
    SendNotificationResponseDTO
from ib_notifications.exceptions.exceptions import InvalidDeviceTypeException
from ib_notifications.interactors.presenters.presenter_interface import \
    PresenterInterface
from ib_notifications.interactors.storages.storage_interface import \
    StorageInterface
from ib_notifications.services.cloud_messaging_interface import \
    CloudMessagingInterface


class SendNotificationToUsersInteractor:

    def __init__(self, storage: StorageInterface):
        self.storage = storage

    def send_notification_to_users_response(
            self, user_ids: List[str],
            notification_message_dto: NotificationMessageDTO,
            cloud_message_provider: CloudMessagingInterface,
            log_notification: bool, device_types: List,
            presenter: PresenterInterface):

        try:
            user_ids_without_cm_token_dto = self.send_notification_to_users(
                user_ids=user_ids,
                cloud_message_provider=cloud_message_provider,
                notification_message_dto=notification_message_dto,
                log_notification=log_notification, device_types=device_types)
        except InvalidDeviceTypeException:
            presenter.raise_invalid_device_type()
            return

        return presenter.get_send_notification_to_user_response(
            user_ids_without_cm_token_dto=user_ids_without_cm_token_dto)

    def send_notification_to_users(
            self, user_ids: List[str],
            notification_message_dto: NotificationMessageDTO,
            log_notification: bool, device_types: List,
            cloud_message_provider: CloudMessagingInterface
    ):

        notification_message_dto.notification_id = (
            notification_message_dto.notification_id
            if notification_message_dto.notification_id else str(uuid.uuid4())
        )

        self._check_if_device_types_are_invalid(device_types=device_types)

        user_id_with_cm_token_dtos = self._get_user_id_with_cm_token_dtos(
            user_ids=user_ids, device_types=device_types)
        user_ids_without_cm_token = self._get_user_ids_without_cm_token(
            user_id_with_cm_token_dtos=user_id_with_cm_token_dtos,
            all_user_ids=user_ids)

        service_response_dict = self._send_notification(
            cloud_message_provider=cloud_message_provider,
            user_id_with_cm_token_dtos=user_id_with_cm_token_dtos,
            notification_message_dto=notification_message_dto)

        if log_notification:
            self._log_notification(
                user_ids=user_ids,
                notification_message_dto=notification_message_dto,
                service_response_dict=service_response_dict
            )

        self.storage.delete_user_device_tokens(
            user_device_token_ids=service_response_dict.get("invalid_device_tokens_ids", [])
        )

        user_ids_without_cm_token_dto = SendNotificationResponseDTO(
            user_ids_without_cm_token=user_ids_without_cm_token
        )
        return user_ids_without_cm_token_dto

    @staticmethod
    def _check_if_device_types_are_invalid(device_types: List[str]):
        valid_device_types = [
            DeviceType.ANDROID.value,
            DeviceType.WEB.value,
            DeviceType.IOS.value
        ]

        for device_type in device_types:
            if device_type not in valid_device_types:
                raise InvalidDeviceTypeException

    def _log_notification(
        self,
        user_ids: List[str],
        notification_message_dto: NotificationMessageDTO,
        service_response_dict: Dict
    ):

        user_ids_without_duplicates = list(set(user_ids))
        self.storage.log_notification(
            user_ids=user_ids_without_duplicates,
            notification_message_dto=notification_message_dto,
            notification_service_response=service_response_dict
        )

    def _get_user_id_with_cm_token_dtos(self, user_ids: List[str],
                                        device_types: List[DeviceType]) -> \
            List[UserIdWithCMToken]:

        is_device_list_empty = not bool(device_types)
        if is_device_list_empty:
            user_id_with_cm_token_dtos = self.storage. \
                get_user_cm_tokens_for_all_device_types(
                    user_ids=user_ids)
        else:
            user_id_with_cm_token_dtos = \
                self.storage.get_user_cm_tokens_for_specific_device_types(
                    user_ids=user_ids, device_types=device_types)

        return user_id_with_cm_token_dtos

    @staticmethod
    def _get_user_ids_without_cm_token(
            user_id_with_cm_token_dtos: List[UserIdWithCMToken],
            all_user_ids: List[str]) -> List[str]:

        user_ids_with_cm_token_dtos = \
            [user.user_id for user in user_id_with_cm_token_dtos]
        user_ids_without_cm_token = \
            list(set(all_user_ids) - set(user_ids_with_cm_token_dtos))

        return list(sorted(user_ids_without_cm_token))

    @staticmethod
    def _send_notification(
        cloud_message_provider: CloudMessagingInterface,
        user_id_with_cm_token_dtos: List[UserIdWithCMToken],
        notification_message_dto: NotificationMessageDTO
    ) -> Dict:

        is_user_id_with_cm_token_dtos_empty = not user_id_with_cm_token_dtos
        if is_user_id_with_cm_token_dtos_empty:
            return {}

        return cloud_message_provider.send_notification(
            cm_token_dtos=user_id_with_cm_token_dtos,
            notification_message_dto=notification_message_dto
        )
