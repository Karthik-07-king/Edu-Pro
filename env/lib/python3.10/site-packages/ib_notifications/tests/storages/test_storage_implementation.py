from datetime import datetime
from typing import List

import factory
import pytest

from ib_notifications.constants.enums import DeviceType
from ib_notifications.dtos.cm_token_with_user_id_dto import \
    UserIdWithCMToken
from ib_notifications.dtos.notification_dto import NotificationDTO
from ib_notifications.dtos.notification_message_dto import \
    NotificationMessageDTO
from ib_notifications.models import Group, GroupUser, Notification
from ib_notifications.models import UserDeviceToken
from ib_notifications.models import UserNotification
from ib_notifications.storages.storage_implementation import \
    StorageImplementation
from ib_notifications.tests.conftest import seed_uuid_generation
from ib_notifications.tests.factories.models import \
    UserNotificationFactory, NotificationFactory


class TestStorageImplementation:

    @pytest.fixture(autouse=True)
    def reset_sequence(self):
        NotificationFactory.reset_sequence(1)
        UserNotificationFactory.reset_sequence(1)

    @pytest.mark.django_db
    def test_create_cloud_message_token_with_valid_input(self):
        user_id = "1"
        device_id = "1"
        device_type = DeviceType.WEB.value
        token = "token 1"
        storage = StorageImplementation()

        storage.create_cloud_message_token(
            user_id=user_id,
            device_id=device_id,
            device_type=device_type,
            token=token
        )

        user_device = UserDeviceToken.objects.get(
            user_id=user_id, device_id=device_id,
            device_type=device_type
        )
        assert user_id == user_device.user_id
        assert device_id == user_device.device_id
        assert device_type == user_device.device_type
        assert token == user_device.token

    @pytest.mark.django_db
    def test_delete_tokens_for_device(self, create_user_device_token):
        user_device = create_user_device_token[2]
        device_id = user_device.device_id
        device_type = user_device.device_type
        storage = StorageImplementation()

        storage.delete_tokens_for_device(
            device_id=device_id, device_type=device_type
        )

        with pytest.raises(UserDeviceToken.DoesNotExist):
            UserDeviceToken.objects.get(
                device_id=device_id,
                device_type=device_type)

    @pytest.mark.django_db
    def test_delete_token_for_user_device(self, create_user_device_token):
        user_device = create_user_device_token[0]
        user_id = user_device.user_id
        device_id = user_device.device_id
        device_type = user_device.device_type
        storage = StorageImplementation()

        storage.delete_token_for_user_device(
            user_id=user_id, device_id=device_id, device_type=device_type
        )

        with pytest.raises(UserDeviceToken.DoesNotExist):
            UserDeviceToken.objects.get(user_id=user_id, device_id=device_id,
                                        device_type=device_type)

    @pytest.mark.django_db
    def test_get_unread_notifications_count(self, user_notifications, user_id):
        expected_count = 2
        storage = StorageImplementation()

        actual_count = storage.get_unread_notifications_count(user_id=user_id)

        assert actual_count == expected_count

    @pytest.mark.django_db
    def test_get_all_notifications_count(self, user_id):

        UserNotificationFactory.create_batch(
            size=3,
            user_id=user_id, is_deleted=True
        )
        UserNotificationFactory.create_batch(
            size=3,
            user_id=user_id, read_at=datetime.now()
        )
        UserNotificationFactory.create_batch(
            size=3,
            user_id=user_id
        )

        expected_count = 6
        storage = StorageImplementation()

        actual_count = storage.get_all_notifications_count(user_id=user_id)

        assert actual_count == expected_count

    @pytest.mark.django_db
    def test_mark_user_notifications_as_read(self):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        user_id = "user_1"

        notifications = NotificationFactory.create_batch(
            size=2, id=factory.Iterator(notification_ids))
        UserNotificationFactory.create_batch(
            size=2, notification=factory.Iterator(notifications))

        storage = StorageImplementation()

        # Act
        storage.mark_user_notifications_as_read(
            user_id=user_id, notification_ids=notification_ids)

        # Assert
        unread_notifications_count = UserNotification.objects.filter(
            user_id=user_id, read_at=None).count()

        assert unread_notifications_count == 0

    @pytest.mark.django_db
    def test_mark_user_notifications_as_unread(self):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"
        ]
        user_id = "user_1"

        notifications = NotificationFactory.create_batch(
            size=2, id=factory.Iterator(notification_ids))
        UserNotificationFactory.create_batch(
            size=2, notification=factory.Iterator(notifications),
            read_at=datetime.now(),
            user_id=user_id
        )

        storage = StorageImplementation()

        # Act
        storage.mark_user_notifications_as_unread(
            user_id=user_id, notification_ids=notification_ids)

        # Assert
        unread_notifications_count = UserNotification.objects.filter(
            user_id=user_id, read_at__isnull=False
        ).count()

        assert unread_notifications_count == 0

    @pytest.mark.django_db
    def test_get_user_notifications(self, user_notifications, user_id):
        offset = 0
        limit = 10
        notification_dtos = self._convert_user_notifications_to_dto(
            user_notifications)
        total_count = len(notification_dtos)
        ordered_notifications = list(reversed(notification_dtos))
        storage = StorageImplementation()

        response_notification_dtos, response_total_count = \
            storage.get_user_notifications(
                user_id=user_id, limit=limit, offset=offset)

        assert response_notification_dtos == ordered_notifications
        assert response_total_count == total_count

    @staticmethod
    def _convert_user_notifications_to_dto(user_notifications):
        notification_dtos = [
            NotificationDTO(
                title=user_notification.notification.title,
                message=user_notification.notification.message,
                extra_data=user_notification.notification.extra_data,
                notification_type=user_notification.notification
                    .notification_type,
                notification_id=user_notification.notification_id,
                read_at=user_notification.read_at,
                created_at=user_notification.notification.created_at
            )
            for user_notification in user_notifications
        ]
        return notification_dtos

    @pytest.mark.django_db
    def test_create_group(self):
        name = "group 1"
        storage = StorageImplementation()

        group_id = storage.create_group(name=name)

        group = Group.objects.get(id=group_id)
        assert group.name == name

    @pytest.mark.django_db
    def test_is_invalid_group_id_with_invalid_group_id(self):
        group_id = 123
        storage = StorageImplementation()
        actual_result = True

        expected_result = storage.is_invalid_group_id(group_id=group_id)

        assert actual_result == expected_result

    @pytest.mark.django_db
    def test_remove_users_from_group(self, create_users_in_group):
        group_id = create_users_in_group[0].id
        remove_user_ids = ["1", "2"]
        user_ids = list(GroupUser.objects.filter(
            group_id=group_id).values_list('user_id', flat=True))
        storage = StorageImplementation()

        storage.remove_users_from_group(group_id=group_id,
                                        user_ids=remove_user_ids)

        remaining_group_user_ids = list(GroupUser.objects.filter(
            group_id=group_id).values_list('user_id', flat=True))

        total_user_ids = remove_user_ids + remaining_group_user_ids
        assert len(user_ids) > len(remaining_group_user_ids)
        assert user_ids == total_user_ids
        assert user_ids not in remaining_group_user_ids

    @pytest.mark.django_db
    def test_add_users_to_group(self, create_users_in_group):
        group_id = create_users_in_group[1].id
        user_ids = ["2", "6"]
        storage = StorageImplementation()

        storage.add_users_to_group(group_id=group_id, user_ids=user_ids)

        added_user_ids = list(GroupUser.objects.filter(
            group_id=group_id).values_list('user_id', flat=True))

        assert len(user_ids) == len(added_user_ids)
        self._check_are_valid_user_ids(user_ids=user_ids,
                                       valid_user_ids=added_user_ids)

    @pytest.mark.django_db
    def test_get_users_from_group(self, create_users_in_group):
        group_id = create_users_in_group[0].id
        valid_user_ids = ["1", "2"]
        storage = StorageImplementation()

        user_ids = storage.get_user_ids_in_group(group_id=group_id)

        assert len(valid_user_ids) == len(user_ids)
        self._check_are_valid_user_ids(user_ids=user_ids,
                                       valid_user_ids=valid_user_ids)

    @staticmethod
    def _check_are_valid_user_ids(user_ids: List[str],
                                  valid_user_ids: List[str]):
        for index, uer_id in enumerate(user_ids):
            assert uer_id == valid_user_ids[index]

    @staticmethod
    def _check_are_user_ids_remove(remove_user_ids: List[str],
                                   remaining_group_user_ids: List[str]):
        for index, remove_user_id in enumerate(remove_user_ids):
            assert remove_user_id != remaining_group_user_ids[index]

    @pytest.mark.django_db
    def test_get_user_ids_for_given_group_id(self, create_users_in_group):
        # Arrange
        storage = StorageImplementation()
        group_id = 1

        expected_result = ['1', '2']

        # Act
        actual_result = storage.get_user_ids_for_given_group_id(
            group_id=group_id)

        # Assert
        assert actual_result == expected_result

    @pytest.mark.django_db
    def test_log_notification(self, snapshot, mocker):
        # Arrange
        storage = StorageImplementation()
        user_ids = ['1', '2']
        expected_result = 2
        notification_dto = NotificationMessageDTO(
            title="System Update!",
            message="version 1.1.0.2",
            extra_data="new update available",
            notification_type="Update"
        )
        seed_uuid_generation(mocker=mocker)
        initial_result = \
            UserNotification.objects.filter(user_id__in=user_ids).count()

        # Act
        storage.log_notification(
            user_ids=user_ids,
            notification_message_dto=notification_dto,
            notification_service_response={"errors": ["invalid_phone_number"]}
        )

        final_result = \
            UserNotification.objects.filter(user_id__in=user_ids).count()

        # Assert
        assert initial_result == 0
        assert final_result == expected_result

        notifications = list(Notification.objects.values(
            "title", "message", "notification_type", "extra_data", "notification_service_response"
        ))
        user_notifications = list(UserNotification.objects.values(
            "user_id", "is_deleted"
        ))
        snapshot.assert_match(name="notifications", value=notifications)
        snapshot.assert_match(name="user_notifications", value=user_notifications)

    @pytest.mark.django_db
    def test_get_user_cm_tokens_for_specific_device_types(
            self, create_user_device_token):
        # Arrange
        storage = StorageImplementation()
        user_ids = ['1', '2', '3']
        expected_result = [
            UserIdWithCMToken(user_id='1', cm_token="token1", device_type=DeviceType.ANDROID.value),
            UserIdWithCMToken(user_id='2', cm_token="token2", device_type=DeviceType.ANDROID.value),
            UserIdWithCMToken(user_id='3', cm_token="token4", device_type=DeviceType.ANDROID.value),
        ]

        device_types = [DeviceType.ANDROID.value]

        # Act
        actual_result = storage.get_user_cm_tokens_for_specific_device_types(
            user_ids=user_ids, device_types=device_types
        )
        # Assert
        assert actual_result == expected_result

    @pytest.mark.django_db
    def test_get_user_cm_tokens_for_all_device_types(
            self, create_user_device_token):
        # Arrange
        storage = StorageImplementation()
        user_ids = ['1', '2', '3']
        expected_result = [
            UserIdWithCMToken(user_id='1', cm_token="token1", device_type=DeviceType.ANDROID.value),
            UserIdWithCMToken(user_id='2', cm_token="token2", device_type=DeviceType.ANDROID.value),
            UserIdWithCMToken(user_id='2', cm_token="token3", device_type=DeviceType.IOS.value),
            UserIdWithCMToken(user_id='3', cm_token="token4", device_type=DeviceType.ANDROID.value),
        ]

        # Act
        actual_result = storage.get_user_cm_tokens_for_all_device_types(
            user_ids=user_ids
        )
        # Assert
        assert actual_result == expected_result

    @pytest.mark.django_db
    def test_check_is_valid_device_id_when_exists_returns_true(self, snapshot):
        # Arrange
        storage = StorageImplementation()

        from ib_notifications.tests.factories.models import \
            UserDeviceTokenFactory
        UserDeviceTokenFactory.reset_sequence(1)

        user_device_token = UserDeviceTokenFactory.create()
        device_id = user_device_token.device_id

        # Act
        result = storage.check_is_valid_device_id(
            device_id=device_id
        )

        # Assert
        snapshot.assert_match(result, "is_valid_device_id")

    @pytest.mark.django_db
    def test_check_is_valid_device_id_when_exists_returns_false(
            self, snapshot):
        # Arrange
        storage = StorageImplementation()

        device_id = "device_1"

        # Act
        result = storage.check_is_valid_device_id(
            device_id=device_id
        )

        # Assert
        snapshot.assert_match(result, "is_valid_device_id")

    @pytest.mark.django_db
    def test_get_valid_user_notification_ids_when_exists_returns_notification_ids(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        user_id = "user_1"

        notifications = NotificationFactory.create_batch(
            size=2, id=factory.Iterator(notification_ids))
        UserNotificationFactory.create_batch(
            size=2, notification=factory.Iterator(notifications),
            user_id=user_id)

        storage = StorageImplementation()

        # Act
        result = storage.get_valid_user_notification_ids(
            user_id=user_id, notification_ids=notification_ids)

        # Assert
        snapshot.assert_match(result, "user_notification_ids")

    @pytest.mark.django_db
    def test_get_valid_user_notification_ids_when_not_exists_returns_empty_list(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        user_id = "user_1"

        storage = StorageImplementation()

        # Act
        result = storage.get_valid_user_notification_ids(
            user_id=user_id, notification_ids=notification_ids)

        # Assert
        snapshot.assert_match(result, "user_notification_ids")

    @pytest.mark.django_db
    def test_get_user_unread_notification_ids_when_exists_returns_notification_ids(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        user_id = "user_1"

        notifications = NotificationFactory.create_batch(
            size=2, id=factory.Iterator(notification_ids))
        UserNotificationFactory.create_batch(
            size=2, notification=factory.Iterator(notifications),
            user_id=user_id)

        storage = StorageImplementation()

        # Act
        result = storage.get_user_unread_notification_ids(user_id=user_id)

        # Assert
        snapshot.assert_match(result, "user_notification_ids")

    @pytest.mark.django_db
    def test_get_user_unread_notification_ids_when_not_exists_returns_empty_list(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        user_id = "user_1"

        notifications = NotificationFactory.create_batch(
            size=2, id=factory.Iterator(notification_ids))
        UserNotificationFactory.create_batch(
            size=2, notification=factory.Iterator(notifications),
            user_id=user_id, read_at="2020-05-06")

        storage = StorageImplementation()

        # Act
        result = storage.get_user_unread_notification_ids(user_id=user_id)

        # Assert
        snapshot.assert_match(result, "user_notification_ids")

    @pytest.mark.django_db
    def test_check_is_valid_notification_id_when_exists_returns_true(
            self, snapshot):
        # Arrange
        notification_id = "059373d4-c877-47f5-873c-2f744f376051"

        NotificationFactory.create(id=notification_id)

        storage = StorageImplementation()

        # Act
        result = storage.check_is_valid_notification_id(
            notification_id=notification_id)

        # Assert
        snapshot.assert_match(result, "is_notification_valid")

    @pytest.mark.django_db
    def test_check_is_valid_notification_id_when_not_exists_returns_false(
            self, snapshot):
        # Arrange
        notification_id = "059373d4-c877-47f5-873c-2f744f376051"

        storage = StorageImplementation()

        # Act
        result = storage.check_is_valid_notification_id(
            notification_id=notification_id)

        # Assert
        snapshot.assert_match(result, "is_notification_valid")

    @pytest.mark.django_db
    def test_get_valid_notification_ids_when_not_exists_returns_empty_list(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]

        storage = StorageImplementation()

        # Act
        result = storage.get_valid_notification_ids(
            notification_ids=notification_ids)

        # Assert
        snapshot.assert_match(result, "valid_notification_ids")

    @pytest.mark.django_db
    def test_get_valid_notification_ids_when_exists_returns_notification_ids(
            self, snapshot):
        # Arrange
        notification_ids = [
            "059373d4-c877-47f5-873c-2f744f376050",
            "059373d4-c877-47f5-873c-2f744f376051"]
        NotificationFactory.create(id=notification_ids[0])

        storage = StorageImplementation()

        # Act
        result = storage.get_valid_notification_ids(
            notification_ids=notification_ids)

        # Assert
        snapshot.assert_match(result, "valid_notification_ids")

    @pytest.mark.django_db
    def test_validate_user_notification_is_unread_when_unread_returns_true(
            self, snapshot):
        # Arrange
        user_id = "user_1"
        notification_id = "059373d4-c877-47f5-873c-2f744f376050"
        notification = NotificationFactory.create(id=notification_id)
        UserNotificationFactory.create(
            notification=notification, read_at=None, user_id=user_id)

        storage = StorageImplementation()

        # Act
        result = storage.validate_user_notification_is_unread(
            notification_id=notification_id, user_id=user_id)

        # Assert
        snapshot.assert_match(result, "is_unread_notification")

    @pytest.mark.django_db
    def test_validate_user_notification_is_unread_when_read_returns_false(
            self, snapshot):
        # Arrange
        user_id = "user_1"
        notification_id = "059373d4-c877-47f5-873c-2f744f376050"
        notification = NotificationFactory.create(id=notification_id)

        import datetime
        UserNotificationFactory.create(
            notification=notification, read_at="2020-05-04", user_id=user_id)

        storage = StorageImplementation()

        # Act
        result = storage.validate_user_notification_is_unread(
            notification_id=notification_id, user_id=user_id)

        # Assert
        snapshot.assert_match(result, "is_unread_notification")
