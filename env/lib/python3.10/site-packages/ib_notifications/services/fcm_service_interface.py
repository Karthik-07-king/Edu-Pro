import json
import logging
from typing import List, Dict, Optional, Tuple
import google
import requests
from ib_notifications.constants.enums import DeviceType
from ib_notifications.constants.exception_messages import \
    FCM_AUTHENTICATION_FAILED, EMPTY_REGISTRATION_IDS, FCM_CONNECTION_FAILED, \
    INVALID_PARAMETER, DEVICE_NOT_REGISTERED
from ib_notifications.dtos.cm_token_with_user_id_dto import UserIdWithCMToken
from ib_notifications.dtos.notification_message_dto import \
    NotificationMessageDTO
from ib_notifications.exceptions.exceptions import \
    FCMAuthenticationFailureException, InvalidParameterException, \
    FCMConnectionFailureException, EmptyRegistrationIdsException, InvalidDeviceTokenException
from ib_notifications.interactors.storages.storage_interface import \
    StorageInterface
from ib_notifications.services.cloud_messaging_interface import \
    CloudMessagingInterface
from requests import Response


class FCMServiceInterface(CloudMessagingInterface):

    def __init__(self, storage: StorageInterface):
        self.storage = storage

    FCM_MAX_TOKENS_LIMIT = 1000

    def send_notification(
            self, cm_token_dtos: List[UserIdWithCMToken],
            notification_message_dto: NotificationMessageDTO
    ) -> Dict:
        (
            android_tokens,
            web_tokens,
            ios_tokens,
            cm_token_device_type_map
        ) = self._prep_device_type_wise_tokens(cm_token_dtos=cm_token_dtos)


        self._validate_registration_ids(cm_token_dtos=cm_token_dtos)

        total_success_count = 0
        total_failure_count = 0
        overall_invalid_device_tokens_ids = []

        credentials, project_id = self._get_fcm_service_credentials()

        non_android_tokens = web_tokens + ios_tokens
        if non_android_tokens:
            failure_count, success_count, invalid_device_tokens = self._send_notification_for_given_tokens(
                registration_ids=non_android_tokens,
                notification_message_dto=notification_message_dto,
                device_type=None, credentials=credentials,
                project_id=project_id
            )
            total_success_count += success_count
            total_failure_count += failure_count
            overall_invalid_device_tokens_ids.extend(invalid_device_tokens)
        if android_tokens:
            failure_count, success_count, invalid_device_tokens  = self._send_notification_for_given_tokens(
                registration_ids=android_tokens,
                notification_message_dto=notification_message_dto,
                device_type=DeviceType.ANDROID.value,
                credentials=credentials, project_id=project_id
            )
            total_success_count += success_count
            total_failure_count += failure_count
            overall_invalid_device_tokens_ids.extend(invalid_device_tokens)

        return {
            "success_count": total_success_count,
            "failure_count": total_failure_count,
            "invalid_device_tokens_ids": overall_invalid_device_tokens_ids
        }

    def _get_fcm_service_credentials(self) -> Tuple[Dict[str, str], str]:
        from ib_notifications.interactors.get_fcm_service_credentials \
            import GetFCMServiceCredentialsInteractor
        interactor = GetFCMServiceCredentialsInteractor(
            storage=self.storage
        )
        return interactor.get_fcm_service_credentials()

    def _send_notification_for_given_tokens(
            self, registration_ids: List[UserIdWithCMToken],
            notification_message_dto: NotificationMessageDTO,
            device_type: Optional[DeviceType],
            credentials: Optional[Dict[str, str]], project_id: str
    ) -> Tuple[int, int, List[int]]:
        success_count, failure_count = 0, 0
        invalid_device_token_ids = []
        for offset in range(
                0, len(registration_ids), self.FCM_MAX_TOKENS_LIMIT
        ):
            selected_ids = registration_ids[
                           offset:offset + self.FCM_MAX_TOKENS_LIMIT
                           ]
            fcm_response = self._send_notification_and_validate_response(
                notification_message_dto=notification_message_dto,
                selected_ids=selected_ids,
                device_type=device_type,
                credentials=credentials, project_id=project_id
            )
            success_count += fcm_response["success"]
            failure_count += fcm_response["failure"]
            invalid_device_token_ids.extend(fcm_response["invalid_device_token_ids"])
        return failure_count, success_count, invalid_device_token_ids

    @staticmethod
    def _prep_device_type_wise_tokens(
            cm_token_dtos: List[UserIdWithCMToken]
    ) -> Tuple[List[UserIdWithCMToken], List[UserIdWithCMToken], List[UserIdWithCMToken], Dict[str, DeviceType]]:
        android_tokens = []
        web_tokens = []
        ios_tokens = []
        cm_token_device_type_map = {}
        for dto in cm_token_dtos:
            if dto.device_type == DeviceType.ANDROID.value:
                android_tokens.append(dto)
            elif dto.device_type == DeviceType.WEB.value:
                web_tokens.append(dto)
            elif dto.device_type == DeviceType.IOS.value:
                ios_tokens.append(dto)
            cm_token_device_type_map[dto.cm_token] = dto.device_type
        return android_tokens, web_tokens, ios_tokens, cm_token_device_type_map

    def _send_notification_and_validate_response(
            self, notification_message_dto: NotificationMessageDTO,
            selected_ids: List[UserIdWithCMToken],
            credentials: Optional[Dict[str, str]], project_id: str,
            device_type: Optional[DeviceType]
    ) -> Dict:
        request_body = self._create_payload_for_request(
            notification_message_dto=notification_message_dto,
            device_type=device_type
        )

        success_count, failure_count = 0, 0
        invalid_device_token_ids = []

        for device_token in selected_ids:
            request_body["message"]["token"] = device_token.cm_token

            fcm_response = self._send_notification_request(
                request_body=request_body,
                credentials=credentials, project_id=project_id
            )

            try:
                self._handle_response(fcm_response=fcm_response)
                success_count += 1
            except InvalidDeviceTokenException as e:
                failure_count += 1
                invalid_device_token_ids.append(device_token.user_device_token_id)
            except Exception as err:
                if isinstance(err, InvalidDeviceTokenException) or fcm_response.status_code == 404:
                    invalid_device_token_ids.append(device_token.user_device_token_id)
                logging.exception(FCM_CONNECTION_FAILED)
                failure_count += 1

        return {"success": success_count, "failure": failure_count, "invalid_device_token_ids": invalid_device_token_ids}

    @staticmethod
    def _create_payload_for_request(
            notification_message_dto: NotificationMessageDTO,
            device_type: Optional[DeviceType]
    ) -> Dict:
        request_body = {
            "message": {
                "notification": {
                    "title": notification_message_dto.title,
                    "body": notification_message_dto.message
                },
                "data": {
                    "notification_id": notification_message_dto.notification_id,
                    "extra_data": notification_message_dto.extra_data,
                    "notification_type": notification_message_dto.notification_type
                }
            }
        }
        if device_type == DeviceType.ANDROID.value:
            channel_id = (
                notification_message_dto.fcm_android_details.channel_id
                if notification_message_dto.fcm_android_details else None
            )
            if channel_id:
                android_data = {
                    "notification": {
                        "channel_id": channel_id
                    }
                }
                # noinspection PyTypeChecker
                request_body["message"].update({"android": android_data})

        return request_body

    def _get_fcm_access_token(
            self, credentials: Optional[Dict[str, str]]
    ) -> str:
        """Retrieve a valid access token that can be used to authorize requests.
        :return: Access token.
        """

        from google.oauth2.service_account import Credentials
        from google.auth.transport.requests import Request


        scopes = ["https://www.googleapis.com/auth/firebase.messaging"]

        credentials = Credentials.from_service_account_info(
            credentials, scopes=scopes
        )
        request = google.auth.transport.requests.Request()
        credentials.refresh(request)
        access_token = credentials.token
        return access_token

    def _send_notification_request(
            self, request_body: Dict,
            credentials: Optional[Dict[str, str]], project_id: str
    ) -> Response:

        access_token = self._get_fcm_access_token(
            credentials=credentials
        )

        fcm_response = requests.post(
            f"https://fcm.googleapis.com/v1/projects/{project_id}/messages:send",
            data=json.dumps(request_body),
            headers={
                'Content-Type': 'application/json',
                'Authorization': f"Bearer {access_token}"
            }
        )
        return fcm_response

    @staticmethod
    def _handle_response(fcm_response: Response):
        status_code = fcm_response.status_code
        if status_code == 401:
            raise FCMAuthenticationFailureException(*FCM_AUTHENTICATION_FAILED)
        elif status_code == 400:
            raise InvalidParameterException(*INVALID_PARAMETER)
        elif 500 <= status_code <= 599:
            raise FCMConnectionFailureException(*FCM_CONNECTION_FAILED)
        elif status_code == 404:
            raise InvalidDeviceTokenException(*DEVICE_NOT_REGISTERED)
        elif status_code == 403:
            raise FCMAuthenticationFailureException(*FCM_AUTHENTICATION_FAILED)

    @staticmethod
    def _validate_registration_ids(cm_token_dtos:List[UserIdWithCMToken],):
        is_empty_registration_ids = len(cm_token_dtos) == 0
        if is_empty_registration_ids:
            raise EmptyRegistrationIdsException(*EMPTY_REGISTRATION_IDS)
