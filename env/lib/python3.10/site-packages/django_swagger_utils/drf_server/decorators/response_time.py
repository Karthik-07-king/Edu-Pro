# coding=utf-8


import json
import logging

from past.utils import old_div
from django_swagger_utils.constants.enums import \
    ResponseLogSelector, RequestLogSelector

logger = logging.getLogger('dsu.debug')


def get_db_time(queries):
    total_time = 0
    from collections import OrderedDict
    queries_data = OrderedDict()
    duplicate_total_queries = 0
    duplicate_unique_queries = 0
    for query in queries:
        query_time = query.get('time')
        if query_time is None:
            # django-debug-toolbar monkeypatches the connection
            # cursor wrapper and adds extra information in each
            # item in connection.queries. The query time is stored
            # under the key "duration" rather than "time" and is
            # in milliseconds, not seconds.
            query_time = old_div(query.get('duration', 0), 1000)
        total_time += float(query_time)
        if query["sql"] not in queries_data:
            queries_data[query["sql"]] = {"count": 1,
                                          "time": float(query_time)}
        else:
            if queries_data[query["sql"]]["count"] == 1:
                duplicate_unique_queries += 1
            duplicate_total_queries += 1
            queries_data[query["sql"]]["count"] += 1
            queries_data[query["sql"]]["time"] += float(query_time)

    queries_data = json.dumps(queries_data)
    return total_time, duplicate_unique_queries, queries_data, \
           duplicate_total_queries


def _get_response(response, response_log_selector):
    from django.http import HttpResponse
    from rest_framework.response import Response
    if isinstance(response, Response):
        result = response.data
    elif isinstance(response, HttpResponse):
        result = response._container[0].decode('utf-8')
    else:
        result = response.data
    from django_swagger_utils.drf_server.decorators.request_response import \
        mask_sensitive_info

    response_log_dict = {
        "status_code": response.status_code,
        "headers": response._headers,
        "cookies": response.cookies
    }

    if response.status_code >= 400:
        response_log_dict['response_data'] = mask_sensitive_info(result)

    elif response_log_selector == \
            ResponseLogSelector.DISABLE_RESPONSE_DATA_ONLY.value:
        response_log_dict['response_data'] = {}

    else:
        response_log_dict['response_data'] = mask_sensitive_info(result)

    return response_log_dict


def response_time(app_name, operation_id, log_config=None):
    """

    :return:
    """

    def decorator(function):
        """

        :param function:
        :return:
        """

        def handler(*args, **kwargs):
            from time import time
            start_time = time()
            from django.db import connection

            request_log_selector, response_log_selector = \
                _get_request_response_log_selector(log_config)

            kwargs["request_log_selector"] = request_log_selector

            return_value = function(*args, **kwargs)
            end_queries = connection.queries
            db_queries_count = len(end_queries)
            db_time, duplicate_queries, db_queries, total_db_queries = \
                get_db_time(end_queries)
            end_time = time()
            total_time = end_time - start_time

            from django.conf import settings
            if getattr(settings, 'LOG_DSU_OLD_VERSION_LOGS', True):
                _dict = {
                    "App Name": app_name,
                    "OperationId": operation_id,
                    "EndpointResponseTime": total_time,
                    "TotalDBQueries": db_queries_count
                }
                logger.debug(_dict)

            from django_swagger_utils import local
            _dict = {
                "api_execution_time": getattr(local, 'api_execution_time', 0),
                "total_db_queries": total_db_queries,
                "db_queries_execution_time": db_time,
                "endpoint_response_time": total_time,
                "log_type": "api_response"
            }
            _dict.update(_get_response(return_value, response_log_selector))

            response_status_code = _dict["status_code"]
            if response_status_code >= 400:
                if request_log_selector in [
                    RequestLogSelector.DISABLE_COMPLETE_LOG.value,
                    RequestLogSelector.DISABLE_REQUEST_DATA_ONLY.value
                ]:
                    request_log_selector = \
                        RequestLogSelector.ENABLE_COMPLETE_LOG.value
                    from django_swagger_utils.drf_server.decorators.\
                        request_response import log_request_data
                    log_request_data(args, request_log_selector)

            _log_response_data(_dict, response_log_selector)

            from django.conf import settings
            if getattr(settings, 'STORE_LATENCY_OBJECT', True):
                from django_swagger_utils.models import Latency
                Latency.objects.create(
                    app_name=app_name,
                    operation_id=operation_id,
                    response_time=total_time,
                    db_queries_count=db_queries_count,
                    db_queries=db_queries,
                    db_time=db_time,
                    duplicate_queries=duplicate_queries,
                    total_duplicate_queries=total_db_queries
                )
            return return_value

        handler.__doc__ = function.__doc__
        return handler

    return decorator


def _log_response_data(_dict, response_log_selector):
    from django.conf import settings
    if getattr(settings, 'LOG_DETAILED_REQUEST_RESPONSE', True):

        required_response_log_selectors = [
            ResponseLogSelector.ENABLE_COMPLETE_LOG.value,
            ResponseLogSelector.DISABLE_RESPONSE_DATA_ONLY.value
        ]
        if response_log_selector in required_response_log_selectors or \
                _dict["status_code"] >= 400:
            if getattr(settings, "REQUEST_RESPONSE_LOG_SIZE_LIMIT", True):
                from django_swagger_utils.drf_server.utils.decorator.\
                    handle_log_limit_response_log import \
                    handle_8kb_log_limit_response_log
                handle_8kb_log_limit_response_log(_dict)
            else:
                import json
                api_response_log_message = json.dumps(_dict)
                logger.debug(api_response_log_message)


def _get_request_response_log_selector(log_config):
    from django_swagger_utils.constants.config import \
        DEFAULT_API_REQUEST_RESPONSE_LOG_CONFIG as default_log_config

    if not log_config:
        log_config = default_log_config

    request_log_selector = log_config['request_log_selector']
    response_log_selector = log_config['response_log_selector']
    request_response_log_probability = \
        log_config.get('request_response_log_probability', 1)

    import random
    random_log_probability = random.random()

    if request_response_log_probability < random_log_probability:

        request_log_selector = \
            _toggle_request_log_selector(request_log_selector)
        response_log_selector = \
            _toggle_response_log_selector(response_log_selector)

    return request_log_selector, response_log_selector


def _toggle_request_log_selector(request_log_selector):
    if request_log_selector in [
        RequestLogSelector.ENABLE_COMPLETE_LOG.value
    ]:
        request_log_selector = \
            RequestLogSelector.DISABLE_COMPLETE_LOG.value

    elif request_log_selector in [
        RequestLogSelector.DISABLE_COMPLETE_LOG,
        RequestLogSelector.DISABLE_REQUEST_DATA_ONLY.value
    ]:
        request_log_selector = \
            RequestLogSelector.ENABLE_COMPLETE_LOG.value

    return request_log_selector


def _toggle_response_log_selector(response_log_selector):
    if response_log_selector in [
        ResponseLogSelector.ENABLE_COMPLETE_LOG.value
    ]:
        response_log_selector = \
            ResponseLogSelector.DISABLE_COMPLETE_LOG.value

    elif response_log_selector in [
        ResponseLogSelector.DISABLE_COMPLETE_LOG,
        ResponseLogSelector.DISABLE_RESPONSE_DATA_ONLY.value
    ]:
        response_log_selector = \
            ResponseLogSelector.ENABLE_COMPLETE_LOG.value

    return response_log_selector
